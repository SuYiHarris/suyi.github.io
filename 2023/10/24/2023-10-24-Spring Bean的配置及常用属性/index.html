<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Spring Bean的配置及常用属性 | 苏弋的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、Java Spring框架是什么？它有哪些好处？Spring 是另一个主流的  Java Web 开发框架，该框架是一个轻量级的应用框架，具有很高的凝聚力和吸引力。Spring 框架因其强大的功能以及卓越的性能而受到众多开发人员的喜爱。 Spring 是分层的 Java SE&#x2F;EE full-stack 轻量级开源框架，以 IoC（Inverse of Control，控制反转）和">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Bean的配置及常用属性">
<meta property="og:url" content="https://suyiharris.github.io/2023/10/24/2023-10-24-Spring%20Bean%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/index.html">
<meta property="og:site_name" content="苏弋的博客">
<meta property="og:description" content="一、Java Spring框架是什么？它有哪些好处？Spring 是另一个主流的  Java Web 开发框架，该框架是一个轻量级的应用框架，具有很高的凝聚力和吸引力。Spring 框架因其强大的功能以及卓越的性能而受到众多开发人员的喜爱。 Spring 是分层的 Java SE&#x2F;EE full-stack 轻量级开源框架，以 IoC（Inverse of Control，控制反转）和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/6537cb31c458853aef587a2e.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/6537cb3fc458853aef58cd12.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/6537cb8bc458853aef5a4357.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/6537cb9fc458853aef5ab3da.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/6537cbbcc458853aef5b3f40.jpg">
<meta property="og:image" content="https://pic.imgdb.cn/item/6537cbcdc458853aef5b981a.jpg">
<meta property="article:published_time" content="2023-10-24T04:12:12.000Z">
<meta property="article:modified_time" content="2023-10-24T13:52:06.347Z">
<meta property="article:author" content="SuYi">
<meta property="article:tag" content="SuYi, Blog, Harris">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/6537cb31c458853aef587a2e.jpg">
  
    <link rel="alternate" href="/atom.xml" title="苏弋的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">苏弋的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">There is no one around me who is you, but there is no one who is not you.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://suyiharris.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2023-10-24-Spring Bean的配置及常用属性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/24/2023-10-24-Spring%20Bean%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/" class="article-date">
  <time class="dt-published" datetime="2023-10-24T04:12:12.000Z" itemprop="datePublished">2023-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Spring Bean的配置及常用属性
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、Java-Spring框架是什么？它有哪些好处？"><a href="#一、Java-Spring框架是什么？它有哪些好处？" class="headerlink" title="一、Java Spring框架是什么？它有哪些好处？"></a>一、Java Spring框架是什么？它有哪些好处？</h1><p>Spring 是另一个主流的  Java Web 开发框架，该框架是一个轻量级的应用框架，具有很高的凝聚力和吸引力。Spring 框架因其强大的功能以及卓越的性能而受到众多开发人员的喜爱。</p>
<p>Spring 是分层的 Java SE&#x2F;EE full-stack 轻量级开源框架，以 IoC（Inverse of Control，控制反转）和 AOP（Aspect Oriented Programming，面向切面编程）为内核，使用基本的 JavaBean 完成以前只可能由 EJB 完成的工作，取代了 EJB 臃肿和低效的开发模式。</p>
<p>在实际开发中，通常服务器端采用三层体系架构，分别为表现层（web）、业务逻辑层（service）、持久层（dao）。</p>
<p>Spring 对每一层都提供了技术支持，在表现层提供了与 </p>
<p>Struts2</p>
<p> 框架的整合，在业务逻辑层可以管理事务和记录日志等，在持久层可以整合 </p>
<p>Hibernate</p>
<p> 和 JdbcTemplate 等技术。</p>
<p>从设计上看，Spring 框架给予了 Java 程序员更高的自由度，对业界的常见问题也提供了良好的解决方案，因此，在开源社区受到了广泛的欢迎，并且被大部分公司作为 Java 项目开发的首选框架。</p>
<p> Spring 具有简单、可测试和松耦合等特点，不仅可以用于服务器端的开发，也可以应用于任何 Java 应用的开发中。Spring 框架的主要优点具体如下。</p>
<h4 id="（1）方便解耦，简化开发"><a href="#（1）方便解耦，简化开发" class="headerlink" title="（1）方便解耦，简化开发"></a>（1）方便解耦，简化开发</h4><p>Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护交给 Spring 管理。</p>
<h4 id="（2）方便集成各种优秀框架"><a href="#（2）方便集成各种优秀框架" class="headerlink" title="（2）方便集成各种优秀框架"></a>（2）方便集成各种优秀框架</h4><p>Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如 Struts2、Hibernate、MyBatis 等）的直接支持。</p>
<h4 id="（3）降低-Java-EE-API-的使用难度"><a href="#（3）降低-Java-EE-API-的使用难度" class="headerlink" title="（3）降低 Java EE API 的使用难度"></a>（3）降低 Java EE API 的使用难度</h4><p>Spring 对 Java EE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了封装，使这些 API 应用的难度大大降低。</p>
<h4 id="（4）方便程序的测试"><a href="#（4）方便程序的测试" class="headerlink" title="（4）方便程序的测试"></a>（4）方便程序的测试</h4><p>Spring 支持 JUnit4，可以通过注解方便地测试 Spring 程序。</p>
<h4 id="（5）AOP-编程的支持"><a href="#（5）AOP-编程的支持" class="headerlink" title="（5）AOP 编程的支持"></a>（5）AOP 编程的支持</h4><p>Spring 提供面向切面编程，可以方便地实现对程序进行权限拦截和运行监控等功能。</p>
<h4 id="（6）声明式事务的支持"><a href="#（6）声明式事务的支持" class="headerlink" title="（6）声明式事务的支持"></a>（6）声明式事务的支持</h4><p>只需要通过配置就可以完成对事务的管理，而无须手动编程。</p>
<h1 id="二、Spring-IoC容器：BeanFactory和ApplicationContext"><a href="#二、Spring-IoC容器：BeanFactory和ApplicationContext" class="headerlink" title="二、Spring IoC容器：BeanFactory和ApplicationContext"></a>二、Spring IoC容器：BeanFactory和ApplicationContext</h1><p>在教程前面介绍 </p>
<p>Spring</p>
<p> 框架时，已经提到过 Spring 的 IoC（控制反转）思想，本节来详细介绍一下 Spring 的 Ioc 容器。</p>
<p>IoC 是指在程序开发中，实例的创建不再由调用者管理，而是由 Spring 容器创建。Spring 容器会负责控制程序之间的关系，而不是由程序代码直接控制，因此，控制权由程序代码转移到了 Spring 容器中，控制权发生了反转，这就是 Spring 的 IoC 思想。</p>
<p>Spring 提供了两种 IoC 容器，分别为 BeanFactory 和 ApplicationContext，接下来将针对这两种 IoC 容器进行详细讲解。</p>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>BeanFactory 是基础类型的 IoC 容器，它由 org.springframework.beans.facytory.BeanFactory 接口定义，并提供了完整的 IoC 服务支持。简单来说，BeanFactory 就是一个管理 Bean 的工厂，它主要负责初始化各种 Bean，并调用它们的生命周期方法。</p>
<p>BeanFactory 接口有多个实现类，最常见的是 org.springframework.beans.factory.xml.XmlBeanFactory，它是根据 XML 配置文件中的定义装配 Bean 的。</p>
<p>创建 BeanFactory 实例时，需要提供 Spring 所管理容器的详细配置信息，这些信息通常采用 XML 文件形式管理。其加载配置信息的代码具体如下所示：</p>
<p>BeanFactory beanFactory &#x3D; new XmlBeanFactory(new FileSystemResource(“D:&#x2F;&#x2F;applicationContext.xml”));</p>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext 是 BeanFactory 的子接口，也被称为应用上下文。该接口的全路径为 org.springframework.context.ApplicationContext，它不仅提供了 BeanFactory 的所有功能，还添加了对 i18n（国际化）、资源访问、事件传播等方面的良好支持。</p>
<p>ApplicationContext 接口有两个常用的实现类，具体如下。</p>
<h4 id="（1）ClassPathXmlApplicationContext"><a href="#（1）ClassPathXmlApplicationContext" class="headerlink" title="（1）ClassPathXmlApplicationContext"></a>（1）ClassPathXmlApplicationContext</h4><p>该类从类路径 ClassPath 中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作，具体如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(String configLocation);</span><br></pre></td></tr></table></figure>



<p>在上述代码中，configLocation 参数用于指定 Spring 配置文件的名称和位置，如 applicationContext.xml。</p>
<h4 id="（2）FileSystemXmlApplicationContext"><a href="#（2）FileSystemXmlApplicationContext" class="headerlink" title="（2）FileSystemXmlApplicationContext"></a>（2）FileSystemXmlApplicationContext</h4><p>该类从指定的文件系统路径中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作，具体如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(String configLocation);</span><br></pre></td></tr></table></figure>



<p>它与 ClassPathXmlApplicationContext 的区别是：在读取 Spring 的配置文件时，FileSystemXmlApplicationContext 不再从类路径中读取配置文件，而是通过参数指定配置文件的位置，它可以获取类路径之外的资源，如“F：&#x2F;workspaces&#x2F;applicationContext.xml”。</p>
<p>在使用 Spring 框架时，可以通过实例化其中任何一个类创建 Spring 的 ApplicationContext 容器。</p>
<p>通常在 </p>
<p>Java</p>
<p> 项目中，会采用通过 ClassPathXmlApplicationContext 类实例化 ApplicationContext 容器的方式，而在 Web 项目中，ApplicationContext 容器的实例化工作会交由 Web 服务器完成。Web 服务器实例化 ApplicationContext 容器通常使用基于 ContextLoaderListener 实现的方式，它只需要在 web.xml 中添加如下代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定Spring配置文件的位置，有多个配置文件时，以逗号分隔--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring将加载spring目录下的applicationContext.xml文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">        classpath:spring/applicationContext.xml</span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，BeanFactory 和 ApplicationContext 都是通过 XML 配置文件加载 Bean 的。</p>
<p>二者的主要区别在于，如果 Bean 的某一个属性没有注入，则使用 BeanFacotry 加载后，在第一次调用 getBean() 方法时会抛出异常，而 ApplicationContext 则在初始化时自检，这样有利于检查所依赖的属性是否注入。</p>
<p>因此，在实际开发中，通常都选择使用 ApplicationContext，而只有在系统资源较少时，才考虑使用 BeanFactory。本教程中使用的就是 ApplicationContext</p>
<h1 id="三、第一个Spring程序"><a href="#三、第一个Spring程序" class="headerlink" title="三、第一个Spring程序"></a>三、第一个Spring程序</h1><p>通过《Spring IoC容器》的学习，读者对 Spring 的 IoC 容器已经有了一个初步的了解。下面通过具体的案例演示 IoC 容器的使用。</p>
<h4 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h4><p>在 MyEclipse 中创建 Web 项目 springDemo01，将 Spring 框架所需的 JAR 包复制到项目的 lib 目录中，并将添加到类路径下，添加后的项目如图 1 所示。</p>
<p><img src="https://pic.imgdb.cn/item/6537cb31c458853aef587a2e.jpg" alt="Spring所需的JAR包"><br>图 1  Spring所需的JAR包</p>
<h4 id="2-创建-PersonDao-接口"><a href="#2-创建-PersonDao-接口" class="headerlink" title="2. 创建 PersonDao 接口"></a>2. 创建 PersonDao 接口</h4><p>在项目的 src 目录下创建一个名为 com.mengma.ioc 的包，然后在该包中创建一个名为 PersonDao 的接口，并在接口中添加一个 add() 方法，如下所示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.mengma.ioc;public interface PersonDao &#123;    public void add();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-创建接口实现类-PersonDaoImpl"><a href="#3-创建接口实现类-PersonDaoImpl" class="headerlink" title="3. 创建接口实现类 PersonDaoImpl"></a>3. 创建接口实现类 PersonDaoImpl</h4><p>在 com.mengma.ioc 包下创建 PersonDao 的实现类 PersonDaoImpl，编辑后如下所示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.mengma.ioc;public class PersonDaoImpl implements PersonDao &#123;    @Override    public void add() &#123;        System.out.println(&quot;save()执行了...&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，PersonDaoImpl 类实现了 PersonDao 接口中的 add() 方法，并且在方法调用时会执行输出语句。</p>
<h4 id="4-创建-Spring-配置文件"><a href="#4-创建-Spring-配置文件" class="headerlink" title="4. 创建 Spring 配置文件"></a>4. 创建 Spring 配置文件</h4><p>在 src 目录下创建 Spring 的核心配置文件 applicationContext.xml，编辑后如下所示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;</span>&gt;</span>    <span class="comment">&lt;!-- 由 Spring容器创建该类的实例对象 --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mengma.ioc.PersonDaoImpl&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，第 2～5 行代码是 Spring 的约束配置，第 7 行代码表示在 Spring 容器中创建一个 id 为 personDao 的 bean 实例，其中 id 表示文件中的唯一标识符，class 属性表示指定需要实例化 Bean 的实全限定类名（包名+类名）。</p>
<p>需要注意的是，Spring 的配置文件名称是可以自定义的，通常情况下，都会将配置文件命名为 applicationContext.xml（或 bean.xml）。</p>
<h4 id="5-编写测试类"><a href="#5-编写测试类" class="headerlink" title="5. 编写测试类"></a>5. 编写测试类</h4><p>在 com.mengma.ioc 包下创建测试类 FirstTest，并在该类中添加一个名为 test1() 的方法，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.ioc;<span class="keyword">import</span> org.junit.Test;<span class="keyword">import</span> org.springframework.context.ApplicationContext;<span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstTest</span> &#123;    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testl</span><span class="params">()</span> &#123;        <span class="comment">// 定义Spring配置文件的路径        String xmlPath = &quot;applicationContext.xml&quot;;        // 初始化Spring容器，加载配置文件        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(                xmlPath);        // 通过容器获取personDao实例        PersonDao personDao = (PersonDao) applicationContext                .getBean(&quot;personDao&quot;);        // 调用 personDao 的 add ()方法        personDao.add();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，首先定义了 Spring 配置文件的路径，然后创建 Spring 容器，接下来通过 Spring 容器获取了 personDao 实例，最后调用实例的 save() 方法。</p>
<h4 id="6-运行项目并查看结果"><a href="#6-运行项目并查看结果" class="headerlink" title="6. 运行项目并查看结果"></a>6. 运行项目并查看结果</h4><p>使用 JUnit 测试运行 test1() 方法，运行成功后，控制台的输出结果如图 2 所示。</p>
<p>从图 2 的输出结果中可以看出，程序已经成功输出了“save()执行了…”语句。在程序执行时，对象的创建并不是通过 new 一个类完成的，而是由 Spring 容器管理实现的。这就是 Spring IoC 容器思想的工作机制。</p>
<p><img src="https://pic.imgdb.cn/item/6537cb3fc458853aef58cd12.jpg" alt="输出结果"></p>
<h1 id="四、Spring-Bean的配置及常用属性"><a href="#四、Spring-Bean的配置及常用属性" class="headerlink" title="四、Spring Bean的配置及常用属性"></a>四、Spring Bean的配置及常用属性</h1><p>作为 <a target="_blank" rel="noopener" href="http://c.biancheng.net/spring/">Spring</a> 核心机制的依赖注入，改变了传统的编程习惯，对组件的实例化不再由应用程序完成，转而交由 Spring 容器完成，在需要时注入应用程序中，从而对组件之间依赖关系进行了解耦。这一切都离不开 Spring 配置文件中使用的 <bean> 元素。  Spring 容器可以被看作一个大工厂，而 Spring 容器中的 Bean 就相当于该工厂的产品。如果希望这个大工厂能够生产和管理 Bean，这时则需要告诉容器需要哪些 Bean，以及需要以何种方式将这些 Bean 装配到一起。  Spring 配置文件支持两种不同的格式，分别是 XML 文件格式和 Properties 文件格式。  通常情况下，Spring 会以 XML 文件格式作为 Spring 的配置文件，这种配置方式通过 XML 文件注册并管理 Bean 之间的依赖关系。  XML 格式配置文件的根元素是 <beans>，该元素包含了多个 <bean> 子元素，每一个 <bean> 子元素定义了一个 Bean，并描述了该 Bean 如何被装配到 Spring 容器中。 </p>
<p> 定义 Bean 的示例代码如下所示： </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用id属性定义person1，其对应的实现类为com.mengma.person1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mengma.damain.Person1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用name属性定义person2，其对应的实现类为com.mengma.domain.Person2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;Person2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mengma.domain.Person2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>在上述代码中，分别使用 id 和 name 属性定义了两个 Bean，并使用 class 元素指定了 Bean 对应的实现类。  </p>
<p><bean> 元素中包含很多属性. </p>
<h1 id="五、Spring-CGLlB动态代理（附带实例）"><a href="#五、Spring-CGLlB动态代理（附带实例）" class="headerlink" title="五、Spring CGLlB动态代理（附带实例）"></a>五、Spring CGLlB动态代理（附带实例）</h1><p>CGLIB（Code Generation Library）是一个高性能开源的代码生成包，它被许多 AOP 框架所使用，其底层是通过使用一个小而快的字节码处理框架 ASM（<a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 字节码操控框架）转换字节码并生成新的类。因此 CGLIB 要依赖于 ASM 的包，解压 <a target="_blank" rel="noopener" href="http://c.biancheng.net/spring/">Spring</a> 的核心包 spring-core-3.2.2.RELEASE.jar，文件目录如图 1 所示。 </p>
<p><img src="https://pic.imgdb.cn/item/6537cb8bc458853aef5a4357.jpg" alt="spring-core-3.2.2.RELEASE.jar文件"> </p>
<p>在图 1 中可以看出，解压的核心包中包含 cglib 和 asm，也就是说 Spring3.2.13 版本的核心包已经集成了 CGLIB 所需要的包，所以在开发中不需要另外导入 ASM 的 JAR 包了。下面通过案例演示实现 CGLIB 的代理过程。 </p>
<h4 id="1-创建目标类-GoodsDao"><a href="#1-创建目标类-GoodsDao" class="headerlink" title="1. 创建目标类 GoodsDao"></a>1. 创建目标类 GoodsDao</h4><p>在 com.mengma.dao 包下创建目标类 GoodsDao，在类中定义增、删、改、查方法，并在每个方法编写输出语句，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.dao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加商品...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改商品...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除商品...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改商品...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-创建代理类-MyBeanFactory"><a href="#2-创建代理类-MyBeanFactory" class="headerlink" title="2. 创建代理类 MyBeanFactory"></a>2. 创建代理类 MyBeanFactory</h4><p>在 src 目录下创建一个名为 com.mengma.cglib 的包，该包下创建类 MyBeanFactory，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.cglib;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.GoodsDao;</span><br><span class="line"><span class="keyword">import</span> com.mengma.jdk.MyAspect;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GoodsDao <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 准备目标类</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">GoodsDao</span> <span class="variable">goodsDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoodsDao</span>();</span><br><span class="line">        <span class="comment">// 创建切面类实例</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">MyAspect</span> <span class="variable">myAspect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAspect</span>();</span><br><span class="line">        <span class="comment">// 生成代理类，CGLIB在运行时，生成指定对象的子类，增强</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 确定需要增强的类</span></span><br><span class="line">        enhancer.setSuperclass(goodsDao.getClass());</span><br><span class="line">        <span class="comment">// 添加回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="comment">// intercept 相当于 jdk invoke，前三个参数与 jdk invoke—致</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args,</span></span><br><span class="line"><span class="params">                    MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                myAspect.myBefore(); <span class="comment">// 前增强</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(goodsDao, args); <span class="comment">// 目标方法执行</span></span><br><span class="line">                myAspect.myAfter(); <span class="comment">// 后增强</span></span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="type">GoodsDao</span> <span class="variable">goodsDaoProxy</span> <span class="operator">=</span> (GoodsDao) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> goodsDaoProxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，应用了 CGLIB 的核心类 Enhancer。在第 19 行代码调用了 Enhancer 类的 setSuperclass() 方法，确定目标对象。</p>
<p>第 21 行代码调用 setCallback() 方法添加回调函数；第 24 行代码的 intercept() 方法相当于 JDK 动态代理方式中的 invoke() 方法，该方法会在目标方法执行的前后，对切面类中的方法进行增强；第 33～34 行代码调用 Enhancer 类的 create() 方法创建代理类，最后将代理类返回。</p>
<h4 id="3-创建测试类"><a href="#3-创建测试类" class="headerlink" title="3. 创建测试类"></a>3. 创建测试类</h4><p>在 com.mengma.cglib 包下创建测试类 CGLIBProxyTest，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.cglib;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.GoodsDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLIBProxyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从工厂获得指定的内容（相当于spring获得，但此内容时代理对象）</span></span><br><span class="line">        <span class="type">GoodsDao</span> <span class="variable">goodsDao</span> <span class="operator">=</span> MyBeanFactory.getBean();</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        goodsDao.add();</span><br><span class="line">        goodsDao.update();</span><br><span class="line">        goodsDao.delete();</span><br><span class="line">        goodsDao.find();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，调用 getBean() 方法时，依然获取的是 goodsDao 的代理对象，然后调用该对象的方法。使用 JUnit 测试运行 test() 方法，运行成功后，控制台的输出结果如图 2 所示。</p>
<p><img src="https://pic.imgdb.cn/item/6537cb9fc458853aef5ab3da.jpg" alt="输出结果"><br>                                        图 2  输出结果</p>
<p>从图 2 的输出结果中可以看出，在调用目标类的方法前后，也成功调用了增强的代码，由此说明，使用 CGLIB 代理的方式同样实现了手动代理。</p>
<h1 id="六、Spring-JDK动态代理（附带实例）"><a href="#六、Spring-JDK动态代理（附带实例）" class="headerlink" title="六、Spring JDK动态代理（附带实例）"></a>六、Spring JDK动态代理（附带实例）</h1><h4 id="1-创建项目-1"><a href="#1-创建项目-1" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h4><p>在 MyEclipse 中创建一个名称为 springDemo03 的 Web 项目，将 </p>
<p>Spring</p>
<p> 支持和依赖的 JAR 包复制到 Web 项目的 WEB-INF&#x2F;lib 目录中，并发布到类路径下。</p>
<h4 id="2-创建接口-CustomerDao"><a href="#2-创建接口-CustomerDao" class="headerlink" title="2. 创建接口 CustomerDao"></a>2. 创建接口 CustomerDao</h4><p>在项目的 src 目录下创建一个名为 com.mengma.dao 的包，在该包下创建一个 CustomerDao 接口，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.dao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>; <span class="comment">// 添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>; <span class="comment">// 修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>; <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">()</span>; <span class="comment">// 查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-创建实现类-CustomerDaoImpl"><a href="#3-创建实现类-CustomerDaoImpl" class="headerlink" title="3. 创建实现类 CustomerDaoImpl"></a>3. 创建实现类 CustomerDaoImpl</h4><p>在 com.mengma.dao 包下创建 CustomerDao 接口的实现类 CustomerDaoImpl，并实现该接口中的所有方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.dao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">CustomerDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加客户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改客户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除客户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改客户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-创建切面类-MyAspect"><a href="#4-创建切面类-MyAspect" class="headerlink" title="4. 创建切面类 MyAspect"></a>4. 创建切面类 MyAspect</h4><p>在 src 目录下，创建一个名为 com.mengma.jdk 的包，在该包下创建一个切面类 MyAspect，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.jdk;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行之前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上述代码中，在切面中定义了两个增强的方法，分别为 myBefore() 方法和 myAfter() 方法，用于对目标类（CustomerDaoImpl）进行增强。 </p>
<h4 id="5-创建代理类-MyBeanFactory"><a href="#5-创建代理类-MyBeanFactory" class="headerlink" title="5. 创建代理类 MyBeanFactory"></a>5. 创建代理类 MyBeanFactory</h4><p>在 com.mengma.jdk 包下创建一个名为 MyBeanFactory 的类，在该类中使用 java.lang.reflect.Proxy 实现 JDK 动态代理，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.jdk;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.CustomerDao;</span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.CustomerDaoImpl;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CustomerDao <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 准备目标类</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CustomerDao</span> <span class="variable">customerDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerDaoImpl</span>();</span><br><span class="line">        <span class="comment">// 创建切面类实例</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">MyAspect</span> <span class="variable">myAspect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAspect</span>();</span><br><span class="line">        <span class="comment">// 使用代理类，进行增强</span></span><br><span class="line">        <span class="keyword">return</span> (CustomerDao) Proxy.newProxyInstance(</span><br><span class="line">                MyBeanFactory.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; CustomerDao.class &#125;, <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method,</span></span><br><span class="line"><span class="params">                            Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        myAspect.myBefore(); <span class="comment">// 前增强</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(customerDao, args);</span><br><span class="line">                        myAspect.myAfter(); <span class="comment">// 后增强</span></span><br><span class="line">                        <span class="keyword">return</span> obj;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，定义了一个静态的 getBean() 方法，这里模拟 Spring 框架的 IoC 思想，通过调用 getBean() 方法创建实例，第 14 行代码创建了 customerDao 实例。 </p>
<p>第 16 行代码创建的切面类实例用于调用切面类中相应的方法；第 18～26 行就是使用代理类对创建的实例 customerDao 中的方法进行增强的代码，其中 Proxy 的 newProxyInstance() 方法的第一个参数是当前类的类加载器，第二参数是所创建实例的实现类的接口，第三个参数就是需要增强的方法。 </p>
<p>在目标类方法执行的前后，分别执行切面类中的 myBefore() 方法和 myAfter() 方法。 </p>
<h4 id="6-创建测试类-JDKProxyTest"><a href="#6-创建测试类-JDKProxyTest" class="headerlink" title="6. 创建测试类 JDKProxyTest"></a>6. 创建测试类 JDKProxyTest</h4><p>在 com.mengma.jdk 包下创建一个名为 JDKProxyTest 的测试类，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.jdk;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.CustomerDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从工厂获得指定的内容（相当于spring获得，但此内容时代理对象）</span></span><br><span class="line">        <span class="type">CustomerDao</span> <span class="variable">customerDao</span> <span class="operator">=</span> MyBeanFactory.getBean();</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        customerDao.add();</span><br><span class="line">        customerDao.update();</span><br><span class="line">        customerDao.delete();</span><br><span class="line">        customerDao.find();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，在调用 getBean() 方法时，获取的是 CustomerDao 类的代理对象，然后调用了该对象中的方法。 </p>
<h4 id="7-运行项目并查看结果"><a href="#7-运行项目并查看结果" class="headerlink" title="7. 运行项目并查看结果"></a>7. 运行项目并查看结果</h4><p>使用 JUnit 测试运行 test() 方法，运行成功后，控制台的输出结果如图 1 所示。</p>
<p>从图 1 的输出结果中可以看出，在调用目标类的方法前后，成功调用了增强的代码，由此说明，JDK 动态代理已经实现。 </p>
<p><img src="https://pic.imgdb.cn/item/6537cbbcc458853aef5b3f40.jpg" alt="运行结果"> </p>
<h1 id="七、注解开发"><a href="#七、注解开发" class="headerlink" title="七、注解开发"></a>七、注解开发</h1><h2 id="1-0-autowired和-resource注解的区别是什么？"><a href="#1-0-autowired和-resource注解的区别是什么？" class="headerlink" title="1.0@autowired和@resource注解的区别是什么？"></a>1.0@autowired和@resource注解的区别是什么？</h2><h3 id="1-1区别："><a href="#1-1区别：" class="headerlink" title="1.1区别："></a>1.1区别：</h3><p>​	1、@Autowired注解由Spring提供，只按照byType注入；@resource注解由J2EE提供，默认按照byName自动注入。</p>
<p>​	2、@Autowired默认按类型进行装配，@Resource默认按照名称进行装配。 </p>
<ul>
<li><h5 id="当注入容器存在多个同一类型的对象时，就是根据byName进行装配的"><a href="#当注入容器存在多个同一类型的对象时，就是根据byName进行装配的" class="headerlink" title="当注入容器存在多个同一类型的对象时，就是根据byName进行装配的"></a>当注入容器存在多个同一类型的对象时，就是根据byName进行装配的</h5></li>
<li><h5 id="当注入在IOC容器中该类型只有一个时，就通过byType进行装配"><a href="#当注入在IOC容器中该类型只有一个时，就通过byType进行装配" class="headerlink" title="当注入在IOC容器中该类型只有一个时，就通过byType进行装配"></a>当注入在IOC容器中该类型只有一个时，就通过byType进行装配</h5></li>
</ul>
<h2 id="1-2解释："><a href="#1-2解释：" class="headerlink" title="1.2解释："></a>1.2解释：</h2><h5 id="autowired"><a href="#autowired" class="headerlink" title="@autowired"></a>@autowired</h5><p>直接在属性上使用，也可以在set方法上使用！</p>
<p>使用Autowired可以不用写set方法了，前提是你这个自动装配的属性在IOC(Spring)容器中存在，且符合名字ByName！</p>
<p>科普：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@nullable</span>  <span class="comment">//字段标记了这个注解表示这个字段可以为null；</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(require = false)</span>  表示这个对象可以为空，反之不可以为空</span><br></pre></td></tr></table></figure>

<h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h5><p>限定哪个bean应该被自动注入。当Spring无法判断出哪个bean应该被注入时，@Qualifier注解有助于消除歧义bean的自动注入。 </p>
<h1 id="八、Spring自动装配Bean"><a href="#八、Spring自动装配Bean" class="headerlink" title="八、Spring自动装配Bean"></a>八、Spring自动装配Bean</h1><p>除了使用 XML 和 Annotation 的方式装配 Bean 以外，还有一种常用的装配方式——自动装配。自动装配就是指 <a target="_blank" rel="noopener" href="http://c.biancheng.net/spring/">Spring</a> 容器可以自动装配（autowire）相互协作的 Bean 之间的关联关系，将一个 Bean 注入其他 Bean 的 Property 中。  </p>
<p>要使用自动装配，就需要配置 <bean> 元素的 autowire 属性。autowire 属性有五个值，具体说明如表 1 所示。 </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byName</td>
<td>根据 Property 的 name 自动装配，如果一个 Bean 的 name 和另一个 Bean 中的 Property 的 name 相同，则自动装配这个 Bean 到 Property 中。</td>
</tr>
<tr>
<td>byType</td>
<td>根据 Property 的数据类型（Type）自动装配，如果一个 Bean 的数据类型兼容另一个 Bean 中 Property 的数据类型，则自动装配。</td>
</tr>
<tr>
<td>constructor</td>
<td>根据构造方法的参数的数据类型，进行 byType 模式的自动装配。</td>
</tr>
<tr>
<td>autodetect</td>
<td>如果发现默认的构造方法，则用 constructor 模式，否则用 byType 模式。</td>
</tr>
<tr>
<td>no</td>
<td>默认情况下，不使用自动装配，Bean 依赖必须通过 ref 元素定义。</td>
</tr>
</tbody></table>
<p>下面通过修改《Spring基于Annotation装配Bean》中的案例演示如何实现自动装配。首先将applicationContext.xml 配置文件修改成自动装配形式，如下所示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;  </span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mengma.annotation.PersonDaoImpl&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mengma.annotation.PersonServiceImpl&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mengma.annotation.PersonAction&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述配置文件中，用于配置 personService 和 personAction 的 <bean> 元素中除了 id 和 class 属性以外，还增加了 autowire 属性，并将其属性值设置为 byName（按属性名称自动装配）。</p>
<p>默认情况下，配置文件中需要通过 ref 装配 Bean，但设置了 autowire&#x3D;”byName”，Spring 会在配置文件中自动寻找与属性名字 personDao 相同的 <bean>，找到后，通过调用 setPersonDao（PersonDao personDao）方法将 id 为 personDao 的 Bean 注入 id 为 personService 的 Bean 中，这时就不需要通过 ref 装配了。</p>
<p>使用 JUnit 再次运行测试类中的 test() 方法，控制台的显示结果如图 1 所示。</p>
<p><img src="https://pic.imgdb.cn/item/6537cbcdc458853aef5b981a.jpg" alt="运行结果"><br>                                        图 1  运行结果</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4254.html">http://c.biancheng.net/view/4254.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://suyiharris.github.io/2023/10/24/2023-10-24-Spring%20Bean%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/" data-id="clo4ezpg3000l00o98t8dg16c" data-title="Spring Bean的配置及常用属性" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/10/24/2023-10-24-%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%B0%E5%BD%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          宝塔面板配置文件记录
        
      </div>
    </a>
  
  
    <a href="/2023/10/24/2023-10-24-SpringBoot%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E7%BB%AD%EF%BC%89/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">SpringBoot：快速入门（续）</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/10/24/2023-10-24-hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2023/10/24/2023-10-24-Git%E5%AD%A6%E4%B9%A0/">2023-10-24-Git学习</a>
          </li>
        
          <li>
            <a href="/2023/10/24/2023-10-24-Jwt%E7%9A%84%E9%89%B4%E6%9D%83%E7%99%BB%E5%BD%95-%E6%8B%A6%E6%88%AA%E5%99%A8-%E6%B3%A8%E5%86%8C%E6%8B%A6%E6%88%AA%E5%99%A8/">Jwt的鉴权登录-拦截器-注册拦截器</a>
          </li>
        
          <li>
            <a href="/2023/10/24/2023-10-24-Linux%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE/">Linux系统部署SpringBoot项目</a>
          </li>
        
          <li>
            <a href="/2023/10/24/2023-10-24-SVN%E5%AD%A6%E4%B9%A0/">SVN学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 SuYi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>