---
title:  "LPC11C14刷卡门锁"
subtitle: "It's always a bit messy"
author: "suyi"
date:   2023-10-24 12:12:12
---

[TOC]

## 产品开发平台

![](https://pic.imgdb.cn/item/6537cd30c458853aef624fbc.jpg)

## 产品使用方法

智能门锁支持RFID刷卡识别，但是卡片需要手动输入初始密码进行授权后才能使用(由于开发板集成高度并且没有多余按键可以使用，所以采用一个按键进行代替)。进行授权的卡片刷卡后会使得风扇开始转动，如果是非法卡，则就会使得引起蜂鸣器报警。进行授权时会在OLED屏幕上面出现相应提示，根据提示进行操作即可。应用界面可以显示当前环境的温度。湿度和光强。在测试时可以通过串口看到读取到的信息。

## 结构框图


![](https://pic.imgdb.cn/item/6537cd3cc458853aef628310.jpg)

## 产品运行流程


![](https://pic.imgdb.cn/item/6537cd4ec458853aef62ce04.jpg)

## 产品运行界面


![](https://pic.imgdb.cn/item/6537cd5bc458853aef6303d1.jpg)


![](https://pic.imgdb.cn/item/6537cd68c458853aef633ad3.jpg)


![](https://pic.imgdb.cn/item/6537cd73c458853aef636d3b.jpg)


![](https://pic.imgdb.cn/item/6537cd7ec458853aef639bec.jpg)

## 程序源码

主函数main.c
~~~c
#include "lpc11xx.h"
#include "oled.h"
#include "uart.h"
#include "rfid.h"
#include "stdio.h"
#include "dht11.h"
#include "light.h"
 
unsigned char keybbuff[20]="@haungqingyaunjain";//支持3个钥匙
//管脚默认输入
//GPIO时钟默认打开
 
void mydelay(int x)
{
	int i,j;
	for(i=0;i<x;i++){
		for(j=0;j<20000;j++){
		
		}
	}
}
 
void delay(int time)
{
	while(time--);
}
 
 
 
/************************					
							
风扇驱动函数
************************/
void faninit()
{
	LPC_GPIO0->DIR|=(0x01<<2);//输出
 
}
 
void fanon()
{
	LPC_GPIO0->DATA&=~(0x01<<2);//低电平
}
 
void fanoff()
{
	LPC_GPIO0->DATA|=(0x01<<2);//高电平
}
 
 
/***************************				
		LED灯驱动函数
****************************/
 
 
void led_init(void)
{
	LPC_GPIO3->DIR |= 0x01;     //输出
}
 
void led_on(void)
{
	LPC_GPIO3->DATA  &= ~0x01;  //低电平
}
 
void led_off(void)
{
	LPC_GPIO3->DATA  |= 0x01;   //高电平
}
 
 
 
void  led2init()
{
	LPC_GPIO3->DIR|=(1<<1);//输出
}
 
void led2on()
{
	LPC_GPIO3->DATA&=~(0x01<<1);//低电平
}
 
void led2off()
{
	LPC_GPIO3->DATA|=(0x01<<1);//高电平
}
 
 
 
///*************************
 
//		蜂鸣器驱动
 
//*************************/
 
//void beepinit()
//{
//	LPC_SYSCON->SYSAHBCLKCTRL|=(0x01<<16);		//GPIO时钟配置
//	LPC_IOCON->R_PIO1_1|=0x01;								//GPIO模式配置（针对复用端口）
//	LPC_GPIO1->DIR|=(1<<1);										//输出
//}
 
 
//void beepon()
//{
//	int j=0;
//	for(j=0;j<10;j++)
//	{
//		LPC_GPIO1->DATA|=(1<<1);//置1
//		delay(5000);
//		LPC_GPIO1->DATA&=~(1<<1);//置0
//		delay(1000);
//	}
//}
 
//void beepoff()
//{
//	LPC_GPIO1->DATA|=(1<<1);//置1
//}
 
 
 
 
/*****************************
	
		按键驱动
******************************/
 
void keyinit()
{
	LPC_GPIO0->DIR&=~(0x01<<3);		//输入
	LPC_GPIO0->IS&=~(0x01<<3);		//边沿触发
	LPC_GPIO0->IBE&=~(0x01<<3);		//关闭双边沿触发
	LPC_GPIO0->IEV&=~(0x01<<3);		//下降沿触发
	LPC_GPIO0->IE|=(0x01<<3);			//打开中断
	NVIC_EnableIRQ(EINT0_IRQn);		//中断使能外部中断0
																//参数在LPCXX.h;
																//core_cm0.h
}
 
 
 
 
 
/**************************
		pwm驱动
***************************/
void PWMinit()
{
	LPC_SYSCON->SYSAHBCLKCTRL|=(0x01<<16);
	LPC_SYSCON->SYSAHBCLKCTRL|=(0x01<<10);
	LPC_IOCON->R_PIO1_1|=0x03;
 
	LPC_TMR32B1->PR=4800;
	LPC_TMR32B1->MR1=10;
	LPC_TMR32B1->MR0=5;
	LPC_TMR32B1->MCR|=(0x01<<4);
	LPC_TMR32B1->EMR|=(0x03<<4);
	LPC_TMR32B1->PWMC|=0x01;
}
 
 
/*******************
	
	打开蜂鸣器
********************/
void beepstart()
{
	LPC_TMR32B1->TCR|=0x01;
}
 
 
/*************************
	关闭蜂鸣器
*************************/
void beepstop()
{
	LPC_TMR32B1->TCR&=~0x01;
}
 
 
/***********************************
	密码验证函数
验证成功返回1，失败返回0
***********************************/
 
 
int keycmp(unsigned char *str)
{
	int i=0;
	int rnum=0;
	int count=0;
	for(i=0;i<16;i++)
	{
		if(keybbuff[i]==str[i+2])
		{
			count++;
		}
	}
	if(count==16)
	rnum=1;
	return rnum;
}
 
/*****************************
开机界面显示函数
*****************************/
 
void display()
{
	char str1[20];
	char str2[20];
	int wendu,shidu,lightval;
	dht11_get(&shidu,&wendu);
	snprintf(str1,sizeof(str1),"shidu:%d   wendu:%d",shidu,wendu);
	lightval=light_get();
	snprintf(str2,sizeof(str2),"guangqiang:%d",lightval);
	oled_clear_screen();
	oled_disp_string(0,0,"   welcome to here");
	oled_disp_string(2,0,str1);
	oled_disp_string(4,0,str2);
	oled_disp_string(6,0," dream is possible");
}
 
 
int main(void)
{
	int state;
	led_init();				//LED1初始化
	oled_init();			//OLED初始化
	led2init();				//LED2初始化
	rfid_init();			//rfid初始化
	uart_init();			//串口初始化
	faninit();				//风扇初始化
 	PWMinit();				//蜂鸣器初始化
	keyinit();				//按键初始化
	light_init();
	dht11_init();
	oled_disp_string(0,0,"  welcome to use it");			
	oled_disp_string(1,0,"     group nine");
	while(1)
	{
		state=rfid_state();
		if(state)							//寻卡
		{
			printf("找到卡片\r\n");			//串口打印
			rfid_read();									//ID号读取
			printf("%s\r\n",(buf+2));			//串口打印ID卡号
			if(keycmp(buf)==1&&state==1)						//ID卡号比较
			{
				led2off();
				fanon();
				mydelay(150);
				fanoff();
				mydelay(10);
			}
			else 
			{
				beepstart();
				mydelay(50);
				beepstop();
				led2on();
			}
			display();
		}
		led_on();
	}
 
}
 
 
/********************
按键中断处理函数
********************/
 
 
void PIOINT0_IRQHandler()
{
	int i=0;
	if(LPC_GPIO0->RIS&(0x01<<3))//中断发生标志位判断
	{
		oled_clear_screen();
		oled_disp_string(0,0,"    mode:add key   ");
		oled_disp_string(2,0,"  put card on rfid");
		while(rfid_state()==0);				//等待卡片被放下
		rfid_read();
		for(i=0;i<36;i++)
		{
			keybbuff[i]=buf[i+2];				
		}
		printf("addkeyID:%s\r\n",keybbuff);
//		while(rfid_state()==1);				//等待卡片被拿起
///*****************************************************
//
//此处代码存在bug，经检测与软件无关，卡片没有拿起，就直接进入
//下面的函数，直接跳过了while()循环，多次修改无效，为硬件问题
//有些东西用while(1)也留不住，就像中断一样，来得突然，离开莫
//名其妙。
//******************************************************/			
		oled_clear_screen();
		oled_disp_string(0,0,"   add sucessfully");
		mydelay(500);
		LPC_GPIO0->IC|=(0x01<<3);//清除中断标志位
	}
}

~~~


## 温度传感器驱动

dth11.h

~~~c
#ifndef __DHT_H__
#define __DHT_H__
 
void dht11_init(void);
int dht11_get(int *h, int *t);
 
#endif
~~~

dth11.c

~~~c
#include "LPC11xx.h"
 
void Delay10uS(void)
{
	int i = 45;
	while (i--);
}
 
void Delay10mS(void)
{
	int i = 1000;
	while (i--)
		Delay10uS();
}
 
void dht11_init(void)
{
	int i = 100;
	
	LPC_GPIO1->DIR |= 1 << 5;
	LPC_GPIO1->DATA |= 1 << 5;
	
	while (i--)
		Delay10mS();   
}
//严格根据 dht11时序读取
 
int dht11_get(int  *h, int *t)
{
	int i;
	int cnt = 0;
	unsigned char data[5] = {0};
	
	__disable_irq();
 
again:
	LPC_GPIO1->DIR |= 1 << 5;
	LPC_GPIO1->DATA |= 1 << 5;
	Delay10mS();
	/* 低电平保持18mS */
	LPC_GPIO1->DATA &= ~(1 << 5);
	Delay10mS();
	Delay10mS();
	LPC_GPIO1->DATA |= 1 << 5;
	
	LPC_GPIO1->DIR &= ~(1 << 5);
	Delay10uS();
	Delay10uS();
	Delay10uS();
	/* 等待DHT11输出低电平 */
	if (LPC_GPIO1->DATA & (1 << 5))
		goto again;
	
	/* 等待低电平结束，80uS */
	while (!(LPC_GPIO1->DATA & (1 << 5))) {
		Delay10uS();
		++cnt;
	}
	
	/* 开始输出高电平，80uS */
	cnt = 0;
	while (LPC_GPIO1->DATA & (1 << 5)) {
		Delay10uS();
		++cnt;
	}
 
	for (i = 0; i < 40; i++) {
		/* 等待低电平结束，50uS */
		while (!(LPC_GPIO1->DATA & (1 << 5)));
		/* 对高电平进行计时 */
		cnt = 0;
		while (LPC_GPIO1->DATA & (1 << 5)) {
			Delay10uS();
			++cnt;
		}
		if (cnt > 5)
			data[i / 8] |= 1 << (7 - i % 8);
		cnt = 0;
	}
	
	__enable_irq();
	
	Delay10mS();
	LPC_GPIO1->DIR |= 1 << 5;
	LPC_GPIO1->DATA |= 1 << 5;
	
	if ((unsigned char)(data[0] + data[1] + data[2] + data[3]) != data[4])
		return -1;
	else {
		*h = data[0];
		*t = data[2];
		return 0;
	}
}
~~~


## OLED显示屏驱动

ascii.h
~~~c
#ifndef __ASCII_H__
#define __ASCII_H__
 
const unsigned char ASCII[241][5]={        // Refer to "Times New Roman" Font Database...
                                                                //   Basic Characters
    {0x00,0x00,0x00,0x00,0x00},        //   (  0)    - 0x0020 Space
    {0x00,0x00,0x4F,0x00,0x00},        //   (  1)  ! - 0x0021 Exclamation Mark
    {0x00,0x07,0x00,0x07,0x00},        //   (  2)  " - 0x0022 Quotation Mark
    {0x14,0x7F,0x14,0x7F,0x14},        //   (  3)  # - 0x0023 Number Sign
    {0x24,0x2A,0x7F,0x2A,0x12},        //   (  4)  $ - 0x0024 Dollar Sign
    {0x23,0x13,0x08,0x64,0x62},        //   (  5)  % - 0x0025 Percent Sign
    {0x36,0x49,0x55,0x22,0x50},        //   (  6)  & - 0x0026 Ampersand
    {0x00,0x05,0x03,0x00,0x00},        //   (  7)  ' - 0x0027 Apostrophe
    {0x00,0x1C,0x22,0x41,0x00},        //   (  8)  ( - 0x0028 Left Parenthesis
    {0x00,0x41,0x22,0x1C,0x00},        //   (  9)  ) - 0x0029 Right Parenthesis
    {0x14,0x08,0x3E,0x08,0x14},        //   ( 10)  * - 0x002A Asterisk
    {0x08,0x08,0x3E,0x08,0x08},        //   ( 11)  + - 0x002B Plus Sign
    {0x00,0x50,0x30,0x00,0x00},        //   ( 12)  , - 0x002C Comma
    {0x08,0x08,0x08,0x08,0x08},        //   ( 13)  - - 0x002D Hyphen-Minus
    {0x00,0x60,0x60,0x00,0x00},        //   ( 14)  . - 0x002E Full Stop
    {0x20,0x10,0x08,0x04,0x02},        //   ( 15)  / - 0x002F Solidus
    {0x3E,0x51,0x49,0x45,0x3E},        //   ( 16)  0 - 0x0030 Digit Zero
    {0x00,0x42,0x7F,0x40,0x00},        //   ( 17)  1 - 0x0031 Digit One
    {0x42,0x61,0x51,0x49,0x46},        //   ( 18)  2 - 0x0032 Digit Two
    {0x21,0x41,0x45,0x4B,0x31},        //   ( 19)  3 - 0x0033 Digit Three
    {0x18,0x14,0x12,0x7F,0x10},        //   ( 20)  4 - 0x0034 Digit Four
    {0x27,0x45,0x45,0x45,0x39},        //   ( 21)  5 - 0x0035 Digit Five
    {0x3C,0x4A,0x49,0x49,0x30},        //   ( 22)  6 - 0x0036 Digit Six
    {0x01,0x71,0x09,0x05,0x03},        //   ( 23)  7 - 0x0037 Digit Seven
    {0x36,0x49,0x49,0x49,0x36},        //   ( 24)  8 - 0x0038 Digit Eight
    {0x06,0x49,0x49,0x29,0x1E},        //   ( 25)  9 - 0x0039 Dight Nine
    {0x00,0x36,0x36,0x00,0x00},        //   ( 26)  : - 0x003A Colon
    {0x00,0x56,0x36,0x00,0x00},        //   ( 27)  ; - 0x003B Semicolon
    {0x08,0x14,0x22,0x41,0x00},        //   ( 28)  < - 0x003C Less-Than Sign
    {0x14,0x14,0x14,0x14,0x14},        //   ( 29)  = - 0x003D Equals Sign
    {0x00,0x41,0x22,0x14,0x08},        //   ( 30)  > - 0x003E Greater-Than Sign
    {0x02,0x01,0x51,0x09,0x06},        //   ( 31)  ? - 0x003F Question Mark
    {0x32,0x49,0x79,0x41,0x3E},        //   ( 32)  @ - 0x0040 Commercial At
    {0x7E,0x11,0x11,0x11,0x7E},        //   ( 33)  A - 0x0041 Latin Capital Letter A
    {0x7F,0x49,0x49,0x49,0x36},        //   ( 34)  B - 0x0042 Latin Capital Letter B
    {0x3E,0x41,0x41,0x41,0x22},        //   ( 35)  C - 0x0043 Latin Capital Letter C
    {0x7F,0x41,0x41,0x22,0x1C},        //   ( 36)  D - 0x0044 Latin Capital Letter D
    {0x7F,0x49,0x49,0x49,0x41},        //   ( 37)  E - 0x0045 Latin Capital Letter E
    {0x7F,0x09,0x09,0x09,0x01},        //   ( 38)  F - 0x0046 Latin Capital Letter F
    {0x3E,0x41,0x49,0x49,0x7A},        //   ( 39)  G - 0x0047 Latin Capital Letter G
    {0x7F,0x08,0x08,0x08,0x7F},        //   ( 40)  H - 0x0048 Latin Capital Letter H
    {0x00,0x41,0x7F,0x41,0x00},        //   ( 41)  I - 0x0049 Latin Capital Letter I
    {0x20,0x40,0x41,0x3F,0x01},        //   ( 42)  J - 0x004A Latin Capital Letter J
    {0x7F,0x08,0x14,0x22,0x41},        //   ( 43)  K - 0x004B Latin Capital Letter K
    {0x7F,0x40,0x40,0x40,0x40},        //   ( 44)  L - 0x004C Latin Capital Letter L
    {0x7F,0x02,0x0C,0x02,0x7F},        //   ( 45)  M - 0x004D Latin Capital Letter M
    {0x7F,0x04,0x08,0x10,0x7F},        //   ( 46)  N - 0x004E Latin Capital Letter N
    {0x3E,0x41,0x41,0x41,0x3E},        //   ( 47)  O - 0x004F Latin Capital Letter O
    {0x7F,0x09,0x09,0x09,0x06},        //   ( 48)  P - 0x0050 Latin Capital Letter P
    {0x3E,0x41,0x51,0x21,0x5E},        //   ( 49)  Q - 0x0051 Latin Capital Letter Q
    {0x7F,0x09,0x19,0x29,0x46},        //   ( 50)  R - 0x0052 Latin Capital Letter R
    {0x46,0x49,0x49,0x49,0x31},        //   ( 51)  S - 0x0053 Latin Capital Letter S
    {0x01,0x01,0x7F,0x01,0x01},        //   ( 52)  T - 0x0054 Latin Capital Letter T
    {0x3F,0x40,0x40,0x40,0x3F},        //   ( 53)  U - 0x0055 Latin Capital Letter U
    {0x1F,0x20,0x40,0x20,0x1F},        //   ( 54)  V - 0x0056 Latin Capital Letter V
    {0x3F,0x40,0x38,0x40,0x3F},        //   ( 55)  W - 0x0057 Latin Capital Letter W
    {0x63,0x14,0x08,0x14,0x63},        //   ( 56)  X - 0x0058 Latin Capital Letter X
    {0x07,0x08,0x70,0x08,0x07},        //   ( 57)  Y - 0x0059 Latin Capital Letter Y
    {0x61,0x51,0x49,0x45,0x43},        //   ( 58)  Z - 0x005A Latin Capital Letter Z
    {0x00,0x7F,0x41,0x41,0x00},        //   ( 59)  [ - 0x005B Left Square Bracket
    {0x02,0x04,0x08,0x10,0x20},        //   ( 60)  \ - 0x005C Reverse Solidus
    {0x00,0x41,0x41,0x7F,0x00},        //   ( 61)  ] - 0x005D Right Square Bracket
    {0x04,0x02,0x01,0x02,0x04},        //   ( 62)  ^ - 0x005E Circumflex Accent
    {0x40,0x40,0x40,0x40,0x40},        //   ( 63)  _ - 0x005F Low Line
    {0x01,0x02,0x04,0x00,0x00},        //   ( 64)  ` - 0x0060 Grave Accent
    {0x20,0x54,0x54,0x54,0x78},        //   ( 65)  a - 0x0061 Latin Small Letter A
    {0x7F,0x48,0x44,0x44,0x38},        //   ( 66)  b - 0x0062 Latin Small Letter B
    {0x38,0x44,0x44,0x44,0x20},        //   ( 67)  c - 0x0063 Latin Small Letter C
    {0x38,0x44,0x44,0x48,0x7F},        //   ( 68)  d - 0x0064 Latin Small Letter D
    {0x38,0x54,0x54,0x54,0x18},        //   ( 69)  e - 0x0065 Latin Small Letter E
    {0x08,0x7E,0x09,0x01,0x02},        //   ( 70)  f - 0x0066 Latin Small Letter F
    {0x06,0x49,0x49,0x49,0x3F},        //   ( 71)  g - 0x0067 Latin Small Letter G
    {0x7F,0x08,0x04,0x04,0x78},        //   ( 72)  h - 0x0068 Latin Small Letter H
    {0x00,0x44,0x7D,0x40,0x00},        //   ( 73)  i - 0x0069 Latin Small Letter I
    {0x20,0x40,0x44,0x3D,0x00},        //   ( 74)  j - 0x006A Latin Small Letter J
    {0x7F,0x10,0x28,0x44,0x00},        //   ( 75)  k - 0x006B Latin Small Letter K
    {0x00,0x41,0x7F,0x40,0x00},        //   ( 76)  l - 0x006C Latin Small Letter L
    {0x7C,0x04,0x18,0x04,0x7C},        //   ( 77)  m - 0x006D Latin Small Letter M
    {0x7C,0x08,0x04,0x04,0x78},        //   ( 78)  n - 0x006E Latin Small Letter N
    {0x38,0x44,0x44,0x44,0x38},        //   ( 79)  o - 0x006F Latin Small Letter O
    {0x7C,0x14,0x14,0x14,0x08},        //   ( 80)  p - 0x0070 Latin Small Letter P
    {0x08,0x14,0x14,0x18,0x7C},        //   ( 81)  q - 0x0071 Latin Small Letter Q
    {0x7C,0x08,0x04,0x04,0x08},        //   ( 82)  r - 0x0072 Latin Small Letter R
    {0x48,0x54,0x54,0x54,0x20},        //   ( 83)  s - 0x0073 Latin Small Letter S
    {0x04,0x3F,0x44,0x40,0x20},        //   ( 84)  t - 0x0074 Latin Small Letter T
    {0x3C,0x40,0x40,0x20,0x7C},        //   ( 85)  u - 0x0075 Latin Small Letter U
    {0x1C,0x20,0x40,0x20,0x1C},        //   ( 86)  v - 0x0076 Latin Small Letter V
    {0x3C,0x40,0x30,0x40,0x3C},        //   ( 87)  w - 0x0077 Latin Small Letter W
    {0x44,0x28,0x10,0x28,0x44},        //   ( 88)  x - 0x0078 Latin Small Letter X
    {0x0C,0x50,0x50,0x50,0x3C},        //   ( 89)  y - 0x0079 Latin Small Letter Y
    {0x44,0x64,0x54,0x4C,0x44},        //   ( 90)  z - 0x007A Latin Small Letter Z
    {0x00,0x08,0x36,0x41,0x00},        //   ( 91)  { - 0x007B Left Curly Bracket
    {0x00,0x00,0x7F,0x00,0x00},        //   ( 92)  | - 0x007C Vertical Line
    {0x00,0x41,0x36,0x08,0x00},        //   ( 93)  } - 0x007D Right Curly Bracket
    {0x02,0x01,0x02,0x04,0x02},        //   ( 94)  ~ - 0x007E Tilde
    {0x3E,0x55,0x55,0x41,0x22},        //   ( 95)  C - 0x0080 <Control>
    {0x00,0x00,0x00,0x00,0x00},        //   ( 96)    - 0x00A0 No-Break Space
    {0x00,0x00,0x79,0x00,0x00},        //   ( 97)  ! - 0x00A1 Inverted Exclamation Mark
    {0x18,0x24,0x74,0x2E,0x24},        //   ( 98)  c - 0x00A2 Cent Sign
    {0x48,0x7E,0x49,0x42,0x40},        //   ( 99)  L - 0x00A3 Pound Sign
    {0x5D,0x22,0x22,0x22,0x5D},        //   (100)  o - 0x00A4 Currency Sign
    {0x15,0x16,0x7C,0x16,0x15},        //   (101)  Y - 0x00A5 Yen Sign
    {0x00,0x00,0x77,0x00,0x00},        //   (102)  | - 0x00A6 Broken Bar
    {0x0A,0x55,0x55,0x55,0x28},        //   (103)    - 0x00A7 Section Sign
    {0x00,0x01,0x00,0x01,0x00},        //   (104)  " - 0x00A8 Diaeresis
    {0x00,0x0A,0x0D,0x0A,0x04},        //   (105)    - 0x00AA Feminine Ordinal Indicator
    {0x08,0x14,0x2A,0x14,0x22},        //   (106) << - 0x00AB Left-Pointing Double Angle Quotation Mark
    {0x04,0x04,0x04,0x04,0x1C},        //   (107)    - 0x00AC Not Sign
    {0x00,0x08,0x08,0x08,0x00},        //   (108)  - - 0x00AD Soft Hyphen
    {0x01,0x01,0x01,0x01,0x01},        //   (109)    - 0x00AF Macron
    {0x00,0x02,0x05,0x02,0x00},        //   (110)    - 0x00B0 Degree Sign
    {0x44,0x44,0x5F,0x44,0x44},        //   (111) +- - 0x00B1 Plus-Minus Sign
    {0x00,0x00,0x04,0x02,0x01},        //   (112)  ` - 0x00B4 Acute Accent
    {0x7E,0x20,0x20,0x10,0x3E},        //   (113)  u - 0x00B5 Micro Sign
    {0x06,0x0F,0x7F,0x00,0x7F},        //   (114)    - 0x00B6 Pilcrow Sign
    {0x00,0x18,0x18,0x00,0x00},        //   (115)  . - 0x00B7 Middle Dot
    {0x00,0x40,0x50,0x20,0x00},        //   (116)    - 0x00B8 Cedilla
    {0x00,0x0A,0x0D,0x0A,0x00},        //   (117)    - 0x00BA Masculine Ordinal Indicator
    {0x22,0x14,0x2A,0x14,0x08},        //   (118) >> - 0x00BB Right-Pointing Double Angle Quotation Mark
    {0x17,0x08,0x34,0x2A,0x7D},        //   (119) /4 - 0x00BC Vulgar Fraction One Quarter
    {0x17,0x08,0x04,0x6A,0x59},        //   (120) /2 - 0x00BD Vulgar Fraction One Half
    {0x30,0x48,0x45,0x40,0x20},        //   (121)  ? - 0x00BF Inverted Question Mark
    {0x70,0x29,0x26,0x28,0x70},        //   (122) `A - 0x00C0 Latin Capital Letter A with Grave
    {0x70,0x28,0x26,0x29,0x70},        //   (123) 'A - 0x00C1 Latin Capital Letter A with Acute
    {0x70,0x2A,0x25,0x2A,0x70},        //   (124) ^A - 0x00C2 Latin Capital Letter A with Circumflex
    {0x72,0x29,0x26,0x29,0x70},        //   (125) ~A - 0x00C3 Latin Capital Letter A with Tilde
    {0x70,0x29,0x24,0x29,0x70},        //   (126) "A - 0x00C4 Latin Capital Letter A with Diaeresis
    {0x70,0x2A,0x2D,0x2A,0x70},        //   (127)  A - 0x00C5 Latin Capital Letter A with Ring Above
    {0x7E,0x11,0x7F,0x49,0x49},        //   (128) AE - 0x00C6 Latin Capital Letter Ae
    {0x0E,0x51,0x51,0x71,0x11},        //   (129)  C - 0x00C7 Latin Capital Letter C with Cedilla
    {0x7C,0x55,0x56,0x54,0x44},        //   (130) `E - 0x00C8 Latin Capital Letter E with Grave
    {0x7C,0x55,0x56,0x54,0x44},        //   (131) 'E - 0x00C9 Latin Capital Letter E with Acute
    {0x7C,0x56,0x55,0x56,0x44},        //   (132) ^E - 0x00CA Latin Capital Letter E with Circumflex
    {0x7C,0x55,0x54,0x55,0x44},        //   (133) "E - 0x00CB Latin Capital Letter E with Diaeresis
    {0x00,0x45,0x7E,0x44,0x00},        //   (134) `I - 0x00CC Latin Capital Letter I with Grave
    {0x00,0x44,0x7E,0x45,0x00},        //   (135) 'I - 0x00CD Latin Capital Letter I with Acute
    {0x00,0x46,0x7D,0x46,0x00},        //   (136) ^I - 0x00CE Latin Capital Letter I with Circumflex
    {0x00,0x45,0x7C,0x45,0x00},        //   (137) "I - 0x00CF Latin Capital Letter I with Diaeresis
    {0x7F,0x49,0x49,0x41,0x3E},        //   (138)  D - 0x00D0 Latin Capital Letter Eth
    {0x7C,0x0A,0x11,0x22,0x7D},        //   (139) ~N - 0x00D1 Latin Capital Letter N with Tilde
    {0x38,0x45,0x46,0x44,0x38},        //   (140) `O - 0x00D2 Latin Capital Letter O with Grave
    {0x38,0x44,0x46,0x45,0x38},        //   (141) 'O - 0x00D3 Latin Capital Letter O with Acute
    {0x38,0x46,0x45,0x46,0x38},        //   (142) ^O - 0x00D4 Latin Capital Letter O with Circumflex
    {0x38,0x46,0x45,0x46,0x39},        //   (143) ~O - 0x00D5 Latin Capital Letter O with Tilde
    {0x38,0x45,0x44,0x45,0x38},        //   (144) "O - 0x00D6 Latin Capital Letter O with Diaeresis
    {0x22,0x14,0x08,0x14,0x22},        //   (145)  x - 0x00D7 Multiplcation Sign
    {0x2E,0x51,0x49,0x45,0x3A},        //   (146)  O - 0x00D8 Latin Capital Letter O with Stroke
    {0x3C,0x41,0x42,0x40,0x3C},        //   (147) `U - 0x00D9 Latin Capital Letter U with Grave
    {0x3C,0x40,0x42,0x41,0x3C},        //   (148) 'U - 0x00DA Latin Capital Letter U with Acute
    {0x3C,0x42,0x41,0x42,0x3C},        //   (149) ^U - 0x00DB Latin Capital Letter U with Circumflex
    {0x3C,0x41,0x40,0x41,0x3C},        //   (150) "U - 0x00DC Latin Capital Letter U with Diaeresis
    {0x0C,0x10,0x62,0x11,0x0C},        //   (151) `Y - 0x00DD Latin Capital Letter Y with Acute
    {0x7F,0x12,0x12,0x12,0x0C},        //   (152)  P - 0x00DE Latin Capital Letter Thom
    {0x40,0x3E,0x01,0x49,0x36},        //   (153)  B - 0x00DF Latin Capital Letter Sharp S
    {0x20,0x55,0x56,0x54,0x78},        //   (154) `a - 0x00E0 Latin Small Letter A with Grave
    {0x20,0x54,0x56,0x55,0x78},        //   (155) 'a - 0x00E1 Latin Small Letter A with Acute
    {0x20,0x56,0x55,0x56,0x78},        //   (156) ^a - 0x00E2 Latin Small Letter A with Circumflex
    {0x20,0x55,0x56,0x55,0x78},        //   (157) ~a - 0x00E3 Latin Small Letter A with Tilde
    {0x20,0x55,0x54,0x55,0x78},        //   (158) "a - 0x00E4 Latin Small Letter A with Diaeresis
    {0x20,0x56,0x57,0x56,0x78},        //   (159)  a - 0x00E5 Latin Small Letter A with Ring Above
    {0x24,0x54,0x78,0x54,0x58},        //   (160) ae - 0x00E6 Latin Small Letter Ae
    {0x0C,0x52,0x52,0x72,0x13},        //   (161)  c - 0x00E7 Latin Small Letter c with Cedilla
    {0x38,0x55,0x56,0x54,0x18},        //   (162) `e - 0x00E8 Latin Small Letter E with Grave
    {0x38,0x54,0x56,0x55,0x18},        //   (163) 'e - 0x00E9 Latin Small Letter E with Acute
    {0x38,0x56,0x55,0x56,0x18},        //   (164) ^e - 0x00EA Latin Small Letter E with Circumflex
    {0x38,0x55,0x54,0x55,0x18},        //   (165) "e - 0x00EB Latin Small Letter E with Diaeresis
    {0x00,0x49,0x7A,0x40,0x00},        //   (166) `i - 0x00EC Latin Small Letter I with Grave
    {0x00,0x48,0x7A,0x41,0x00},        //   (167) 'i - 0x00ED Latin Small Letter I with Acute
    {0x00,0x4A,0x79,0x42,0x00},        //   (168) ^i - 0x00EE Latin Small Letter I with Circumflex
    {0x00,0x4A,0x78,0x42,0x00},        //   (169) "i - 0x00EF Latin Small Letter I with Diaeresis
    {0x31,0x4A,0x4E,0x4A,0x30},        //   (170)    - 0x00F0 Latin Small Letter Eth
    {0x7A,0x11,0x0A,0x09,0x70},        //   (171) ~n - 0x00F1 Latin Small Letter N with Tilde
    {0x30,0x49,0x4A,0x48,0x30},        //   (172) `o - 0x00F2 Latin Small Letter O with Grave
    {0x30,0x48,0x4A,0x49,0x30},        //   (173) 'o - 0x00F3 Latin Small Letter O with Acute
    {0x30,0x4A,0x49,0x4A,0x30},        //   (174) ^o - 0x00F4 Latin Small Letter O with Circumflex
    {0x30,0x4A,0x49,0x4A,0x31},        //   (175) ~o - 0x00F5 Latin Small Letter O with Tilde
    {0x30,0x4A,0x48,0x4A,0x30},        //   (176) "o - 0x00F6 Latin Small Letter O with Diaeresis
    {0x08,0x08,0x2A,0x08,0x08},        //   (177)  + - 0x00F7 Division Sign
    {0x38,0x64,0x54,0x4C,0x38},        //   (178)  o - 0x00F8 Latin Small Letter O with Stroke
    {0x38,0x41,0x42,0x20,0x78},        //   (179) `u - 0x00F9 Latin Small Letter U with Grave
    {0x38,0x40,0x42,0x21,0x78},        //   (180) 'u - 0x00FA Latin Small Letter U with Acute
    {0x38,0x42,0x41,0x22,0x78},        //   (181) ^u - 0x00FB Latin Small Letter U with Circumflex
    {0x38,0x42,0x40,0x22,0x78},        //   (182) "u - 0x00FC Latin Small Letter U with Diaeresis
    {0x0C,0x50,0x52,0x51,0x3C},        //   (183) 'y - 0x00FD Latin Small Letter Y with Acute
    {0x7E,0x14,0x14,0x14,0x08},        //   (184)  p - 0x00FE Latin Small Letter Thom
    {0x0C,0x51,0x50,0x51,0x3C},        //   (185) "y - 0x00FF Latin Small Letter Y with Diaeresis
    {0x1E,0x09,0x09,0x29,0x5E},        //   (186)  A - 0x0104 Latin Capital Letter A with Ogonek
    {0x08,0x15,0x15,0x35,0x4E},        //   (187)  a - 0x0105 Latin Small Letter A with Ogonek
    {0x38,0x44,0x46,0x45,0x20},        //   (188) 'C - 0x0106 Latin Capital Letter C with Acute
    {0x30,0x48,0x4A,0x49,0x20},        //   (189) 'c - 0x0107 Latin Small Letter C with Acute
    {0x38,0x45,0x46,0x45,0x20},        //   (190)  C - 0x010C Latin Capital Letter C with Caron
    {0x30,0x49,0x4A,0x49,0x20},        //   (191)  c - 0x010D Latin Small Letter C with Caron
    {0x7C,0x45,0x46,0x45,0x38},        //   (192)  D - 0x010E Latin Capital Letter D with Caron
    {0x20,0x50,0x50,0x7C,0x03},        //   (193) d' - 0x010F Latin Small Letter D with Caron
    {0x1F,0x15,0x15,0x35,0x51},        //   (194)  E - 0x0118 Latin Capital Letter E with Ogonek
    {0x0E,0x15,0x15,0x35,0x46},        //   (195)  e - 0x0119 Latin Small Letter E with Ogonek
    {0x7C,0x55,0x56,0x55,0x44},        //   (196)  E - 0x011A Latin Capital Letter E with Caron
    {0x38,0x55,0x56,0x55,0x18},        //   (197)  e - 0x011B Latin Small Letter E with Caron
    {0x00,0x44,0x7C,0x40,0x00},        //   (198)  i - 0x0131 Latin Small Letter Dotless I
    {0x7F,0x48,0x44,0x40,0x40},        //   (199)  L - 0x0141 Latin Capital Letter L with Stroke
    {0x00,0x49,0x7F,0x44,0x00},        //   (200)  l - 0x0142 Latin Small Letter L with Stroke
    {0x7C,0x08,0x12,0x21,0x7C},        //   (201) 'N - 0x0143 Latin Capital Letter N with Acute
    {0x78,0x10,0x0A,0x09,0x70},        //   (202) 'n - 0x0144 Latin Small Letter N with Acute
    {0x7C,0x09,0x12,0x21,0x7C},        //   (203)  N - 0x0147 Latin Capital Letter N with Caron
    {0x78,0x11,0x0A,0x09,0x70},        //   (204)  n - 0x0148 Latin Small Letter N with Caron
    {0x38,0x47,0x44,0x47,0x38},        //   (205) "O - 0x0150 Latin Capital Letter O with Double Acute
    {0x30,0x4B,0x48,0x4B,0x30},        //   (206) "o - 0x0151 Latin Small Letter O with Double Acute
    {0x3E,0x41,0x7F,0x49,0x49},        //   (207) OE - 0x0152 Latin Capital Ligature Oe
    {0x38,0x44,0x38,0x54,0x58},        //   (208) oe - 0x0153 Latin Small Ligature Oe
    {0x7C,0x15,0x16,0x35,0x48},        //   (209)  R - 0x0158 Latin Capital Letter R with Caron
    {0x78,0x11,0x0A,0x09,0x10},        //   (210)  r - 0x0159 Latin Small Letter R with Caron
    {0x48,0x54,0x56,0x55,0x20},        //   (211) 'S - 0x015A Latin Capital Letter S with Acute
    {0x20,0x48,0x56,0x55,0x20},        //   (212) 's - 0x015B Latin Small Letter S with Acute
    {0x48,0x55,0x56,0x55,0x20},        //   (213)  S - 0x0160 Latin Capital Letter S with Caron
    {0x20,0x49,0x56,0x55,0x20},        //   (214)  s - 0x0161 Latin Small Letter S with Caron
    {0x04,0x05,0x7E,0x05,0x04},        //   (215)  T - 0x0164 Latin Capital Letter T with Caron
    {0x08,0x3C,0x48,0x22,0x01},        //   (216) t' - 0x0165 Latin Small Letter T with Caron
    {0x3C,0x42,0x45,0x42,0x3C},        //   (217)  U - 0x016E Latin Capital Letter U with Ring Above
    {0x38,0x42,0x45,0x22,0x78},        //   (218)  u - 0x016F Latin Small Letter U with Ring Above
    {0x3C,0x43,0x40,0x43,0x3C},        //   (219) "U - 0x0170 Latin Capital Letter U with Double Acute
    {0x38,0x43,0x40,0x23,0x78},        //   (220) "u - 0x0171 Latin Small Letter U with Double Acute
    {0x0C,0x11,0x60,0x11,0x0C},        //   (221) "Y - 0x0178 Latin Capital Letter Y with Diaeresis
    {0x44,0x66,0x55,0x4C,0x44},        //   (222) 'Z - 0x0179 Latin Capital Letter Z with Acute
    {0x48,0x6A,0x59,0x48,0x00},        //   (223) 'z - 0x017A Latin Small Letter Z with Acute
    {0x44,0x64,0x55,0x4C,0x44},        //   (224)  Z - 0x017B Latin Capital Letter Z with Dot Above
    {0x48,0x68,0x5A,0x48,0x00},        //   (225)  z - 0x017C Latin Small Letter Z with Dot Above
    {0x44,0x65,0x56,0x4D,0x44},        //   (226)  Z - 0x017D Latin Capital Letter Z with Caron
    {0x48,0x69,0x5A,0x49,0x00},        //   (227)  z - 0x017E Latin Small Letter Z with Caron
    {0x00,0x02,0x01,0x02,0x00},        //   (228)  ^ - 0x02C6 Modifier Letter Circumflex Accent
    {0x00,0x01,0x02,0x01,0x00},        //   (229)    - 0x02C7 Caron
    {0x00,0x01,0x01,0x01,0x00},        //   (230)    - 0x02C9 Modifier Letter Macron
    {0x01,0x02,0x02,0x01,0x00},        //   (231)    - 0x02D8 Breve
    {0x00,0x00,0x01,0x00,0x00},        //   (232)    - 0x02D9 Dot Above
    {0x00,0x02,0x05,0x02,0x00},        //   (233)    - 0x02DA Ring Above
    {0x02,0x01,0x02,0x01,0x00},        //   (234)  ~ - 0x02DC Small Tilde
    {0x7F,0x05,0x15,0x3A,0x50},        //   (235) Pt - 0x20A7 Peseta Sign
    {0x3E,0x55,0x55,0x41,0x22},        //   (236)  C - 0x20AC Euro Sign
    {0x18,0x14,0x08,0x14,0x0C},        //   (237)    - 0x221E Infinity
    {0x44,0x4A,0x4A,0x51,0x51},        //   (238)  < - 0x2264 Less-Than or Equal to
    {0x51,0x51,0x4A,0x4A,0x44},        //   (239)  > - 0x2265 Greater-Than or Equal to
    {0x74,0x42,0x41,0x42,0x74},        //   (240)    - 0x2302 House
};
 
#endif
~~~

spi.h

~~~c
#ifndef __SPI_H__
#define __SPI_H__
 
#define OLED	0
#define FLASH	1
#define RFID	2
#define UART	3
 
void spi_init(int ch, int rate, int mode);
void spi_write_read(int ch, int slave, unsigned char *wbuf, unsigned char *rbuf, unsigned int len);
unsigned char spi_send(int ch, int slave, unsigned char dat);
 
#endif
~~~

 spi.c

~~~c
#include <LPC11xx.h>
 
#include "spi.h"
 
void spi_init(int ch, int rate, int mode)
{
	if (ch == 0) {
		
		LPC_SYSCON->PRESETCTRL    |= (0x1<<0);
		LPC_SYSCON->SYSAHBCLKCTRL |= (0x1<<11);
		LPC_SYSCON->SSP0CLKDIV     = 24;				/* Divided by 24 */
		LPC_IOCON->PIO0_8         &= ~0x07;			/* SSP I/O config */
		LPC_IOCON->PIO0_8         |= 0x01;			/* SSP MISO */
		LPC_IOCON->PIO0_9         &= ~0x07;	
		LPC_IOCON->PIO0_9         |= 0x01;			/* SSP MOSI */
 
		LPC_IOCON->SCK_LOC = 0x02;
		LPC_IOCON->PIO0_6 = 0x02;								/* P0.6 function 2 is SSP clock, need to 
																							combined with IOCONSCKLOC register setting */  
 
		LPC_SYSCON->SYSAHBCLKCTRL |= (1<<6);
		LPC_IOCON->PIO2_4 &= ~0x07;							/* SSP SSEL0 is a GPIO pin, for OLED */
		LPC_GPIO2->DIR |= 1 << 4;
		LPC_GPIO2->DATA |= 1 << 4;
 
		LPC_IOCON->PIO2_6 &= ~0x07;							/* SSP SSEL1 is a GPIO pin, for FLASH */
		LPC_GPIO2->DIR |= 1 << 6;
		LPC_GPIO2->DATA |= 1 << 6;
 
		LPC_IOCON->PIO2_7 &= ~0x07;							/* SSP SSEL2 is a GPIO pin, for RFID */
		LPC_GPIO2->DIR |= 1 << 7;
		LPC_GPIO2->DATA |= 1 << 7;
	} else {
		LPC_SYSCON->PRESETCTRL    |= (0x1<<2);
		LPC_SYSCON->SYSAHBCLKCTRL |= (1<<18);
		LPC_SYSCON->SSP1CLKDIV     = 24;			/* Divided by 24 */
		LPC_IOCON->PIO2_2         &= ~0x07;		/* SSP I/O config */
		LPC_IOCON->PIO2_2         |= 0x02;		/* SSP MISO */
		LPC_IOCON->PIO2_3         &= ~0x07;	
		LPC_IOCON->PIO2_3         |= 0x02;		/* SSP MOSI */
		LPC_IOCON->PIO2_1         &= ~0x07;
		LPC_IOCON->PIO2_1         |= 0x02;		/* SSP CLK */
	 
		LPC_IOCON->PIO2_0 &= ~0x07;						/* SSP SSEL is a GPIO pin */
		LPC_GPIO2->DIR |= 1 << 0;
		LPC_GPIO2->DATA |= 1 << 0;
	}
	
	if (ch == 0) {
		LPC_SSP0->CPSR = 2;										/* Divided by 2 */
		LPC_SSP0->CR0 = ((1000000 / rate - 1) << 8) | \
										((mode & 1) << 7) | (((mode & 2) >> 1) << 6) | \
										(7 << 0);
		LPC_SSP0->IMSC = 0;										/* disable all interrupts */
		LPC_SSP0->ICR = 3;										/* clears interrupts */
		LPC_SSP0->CR1 = 1 << 1;								/* Master, SPI Enable */
	} else {
		LPC_SSP1->CPSR = 2;										/* Divided by 2 */
		LPC_SSP1->CR0 = ((1000000 / rate - 1) << 8) | \
										((mode & 1) << 7) | (((mode & 2) >> 1) << 6) | \
										(7 << 0);
		LPC_SSP1->IMSC = 0;										/* disable all interrupts */
		LPC_SSP1->ICR = 3;										/* clears interrupts */
		LPC_SSP1->CR1 = 1 << 1;								/* Master, SPI Enable */
	}
}
 
void spi_set_cs(int slave)
{
	switch (slave) {
		case OLED:
			LPC_GPIO2->DATA |= 1 << 4;
			break;
		case FLASH:
			LPC_GPIO2->DATA |= 1 << 6;
			break;
		case RFID:
			LPC_GPIO2->DATA |= 1 << 7;
			break;
		case UART:
			LPC_GPIO2->DATA |= 1 << 0;
			break;
	}
}
 
void spi_clr_cs(int slave)
{
	switch (slave) {
		case OLED:
			LPC_GPIO2->DATA &= ~(1 << 4);
			break;
		case FLASH:
			LPC_GPIO2->DATA &= ~(1 << 6);
			break;
		case RFID:
			LPC_GPIO2->DATA &= ~(1 << 7);
			break;
		case UART:
			LPC_GPIO2->DATA &= ~(1 << 0);
			break;
	}
}
 
void spi_write_read(int ch, int slave, unsigned char *wbuf, unsigned char *rbuf, unsigned int len)
{
	int i = 0;
  if(ch == 0)
  {
		while (i < len) {
			spi_clr_cs(slave);
			while((LPC_SSP0->SR & ((1 << 1) | (1 << 4))) != (1 << 1));
			LPC_SSP0->DR = wbuf[i];
			while(LPC_SSP0->SR & (1 << 4));
 
			while((LPC_SSP0->SR & ((1 << 2) | (1 << 4))) != (1 << 2));
			rbuf[i] = LPC_SSP0->DR;
			spi_set_cs(slave);
			i++;
		}
  } else {
		while (i < len) {
			spi_clr_cs(slave);
			while((LPC_SSP1->SR & ((1 << 1) | (1 << 4))) != (1 << 1));
			LPC_SSP1->DR = wbuf[i];
			while(LPC_SSP1->SR & (1 << 4));
 
			while((LPC_SSP1->SR & ((1 << 2) | (1 << 4))) != (1 << 2));
			rbuf[i] = LPC_SSP1->DR;
			spi_set_cs(slave);
			i++;
		}
  }
}
 
unsigned char spi_send(int ch, int slave, unsigned char dat)
{
	unsigned char c;
	
	spi_write_read(ch, slave, &dat, &c, 1);
	return c;
}
~~~

oled.h

~~~c
#ifndef __OLED_H__
#define __OLED_H__
 
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
 
 
void oled_init(void);
void oled_clear_screen(void);
void oled_disp_char(uint8_t Line, uint16_t Column, uint8_t Color, char c);
void oled_disp_string(uint8_t Line, uint8_t Color, char *ptr);
 
#endif
~~~

oled.c

~~~c
#include <lpc11xx.h>
#include "spi.h"
#include "ascii.h"
 
/******************************************************************************/
/*  Write command & data                                                      */
/******************************************************************************/
void WriteCommand(unsigned char cmd)
{
	LPC_GPIO2->DATA &= ~(1 << 5);
	spi_write_read(0, OLED, &cmd, &cmd, 1);
	LPC_GPIO2->DATA |= 1 << 5;
}
 
void WriteData(unsigned char dat)
{
	LPC_GPIO2->DATA |= 1 << 5;
	spi_write_read(0, OLED, &dat, &dat, 1);
	LPC_GPIO2->DATA |= 1 << 5;
}
 
/******************************************************************************/
/*  Instruction Setting                                                       */
/******************************************************************************/
void SetStartColumn(unsigned char d)
{
	WriteCommand(0x00+d%16);		// Set Lower Column Start Address for Page Addressing Mode
															//	Default => 0x00
	WriteCommand(0x10+d/16);		//	Set Higher Column Start Address for Page Addressing Mode
															//	Default => 0x10
}
 
void SetAddressingMode(unsigned char d)
{
	WriteCommand(0x20);					// Set Memory Addressing Mode
	WriteCommand(d);						//	Default => 0x02
															//	0x00 => Horizontal Addressing Mode
															//	0x01 => Vertical Addressing Mode
															//	0x02 => Page Addressing Mode
}
 
void SetColumnAddress(unsigned char a, unsigned char b)
{
	WriteCommand(0x21);					// Set Column Address
	WriteCommand(a);						//   Default => 0x00 (Column Start Address)
	WriteCommand(b);						//   Default => 0x7F (Column End Address)
}
 
void SetPageAddress(unsigned char a, unsigned char b)
{
	WriteCommand(0x22);					// Set Page Address
	WriteCommand(a);						//   Default => 0x00 (Page Start Address)
	WriteCommand(b);						//   Default => 0x07 (Page End Address)
}
 
void SetStartLine(unsigned char d)
{
	WriteCommand(0x40|d);				// Set Display Start Line
															//   Default => 0x40 (0x00)
}
 
void SetContrastControl(unsigned char d)
{
	WriteCommand(0x81);					// Set Contrast Control
	WriteCommand(d);						//   Default => 0x7F
}
 
void SetChargePump(unsigned char d)
{
	WriteCommand(0x8D);					// Set Charge Pump
	WriteCommand(0x10|d);				//   Default => 0x10
															//     0x10 (0x00) => Disable Charge Pump
															//     0x14 (0x04) => Enable Charge Pump
}
 
void SetSegmentRemap(unsigned char d)
{
	WriteCommand(0xA0|d);				// Set Segment Re-Map
															//	Default => 0xA0
															//	0xA0 (0x00) => Column Address 0 Mapped to SEG0
															//	0xA1 (0x01) => Column Address 0 Mapped to SEG127
}
 
void SetEntireDisplay(unsigned char d)
{
	WriteCommand(0xA4|d);				// Set Entire Display On / Off
															//	Default => 0xA4
															//	0xA4 (0x00) => Normal Display
															//	0xA5 (0x01) => Entire Display On
}
 
void SetInverseDisplay(unsigned char d)
{
	WriteCommand(0xA6|d);				// Set Inverse Display On/Off
															//	Default => 0xA6
															//	0xA6 (0x00) => Normal Display
															//	0xA7 (0x01) => Inverse Display On
}
 
void SetMultiplexRatio(unsigned char d)
{
	WriteCommand(0xA8);					// Set Multiplex Ratio
	WriteCommand(d);						//	Default => 0x3F (1/64 Duty)
}
 
void SetDisplayOnOff(unsigned char d)	
{
	WriteCommand(0xAE|d);				// Set Display On/Off
															//	Default => 0xAE
															//	0xAE (0x00) => Display Off
															//	0xAF (0x01) => Display On
}
 
void SetStartPage(unsigned char d)
{
	WriteCommand(0xB0|d);				// Set Page Start Address for Page Addressing Mode
															//	Default => 0xB0 (0x00)
}
 
void SetCommonRemap(unsigned char d)
{
	WriteCommand(0xC0|d);				// Set COM Output Scan Direction
															//	Default => 0xC0
															//	0xC0 (0x00) => Scan from COM0 to 63
															//	0xC8 (0x08) => Scan from COM63 to 0
}
 
void SetDisplayOffset(unsigned char d)
{
	WriteCommand(0xD3);					// Set Display Offset
	WriteCommand(d);						//   Default => 0x00
}
 
void SetDisplayClock(unsigned char d)
{
	WriteCommand(0xD5);					// Set Display Clock Divide Ratio / Oscillator Frequency
	WriteCommand(d);						//	Default => 0x80
															//	D[3:0] => Display Clock Divider
															//	D[7:4] => Oscillator Frequency
}
 
void SetPrechargePeriod(unsigned char d)
{
	WriteCommand(0xD9);					// Set Pre-Charge Period
	WriteCommand(d);						//	Default => 0x22 (2 Display Clocks [Phase 2] / 2 Display Clocks [Phase 1])
															//	D[3:0] => Phase 1 Period in 1~15 Display Clocks
															//	D[7:4] => Phase 2 Period in 1~15 Display Clocks
}
 
void SetCommonConfig(unsigned char d)
{
	WriteCommand(0xDA);					// Set COM Pins Hardware Configuration
	WriteCommand(0x02|d);				//	Default => 0x12 (0x10)
															//	Alternative COM Pin Configuration
															//	Disable COM Left/Right Re-Map
}
 
void SetVCOMH(unsigned char d)
{
	WriteCommand(0xDB);					// Set VCOMH Deselect Level
	WriteCommand(d);						//   Default => 0x20 (0.77*VCC)
}
 
void SetNOP(void)
{
	WriteCommand(0xE3);					// Command for No Operation
}
 
/******************************************************************************/
/*  Global Variables                                                          */
/******************************************************************************/
#define XLevelL		0x00
#define XLevelH		0x10
#define XLevel		((XLevelH&0x0F)*16+XLevelL)
#define Max_Column	128
#define Max_Row		64
#define	Brightness	0xCF
 
/******************************************************************************/
/*  Show Regular Pattern (Full Screen)                                        */
/******************************************************************************/
void FillRAM(unsigned char Data)
{
	unsigned char i,j;
 
	for(i=0;i<8;i++)
	{
		SetStartPage(i);
		SetStartColumn(0x00);
 
		for(j=0;j<128;j++)
		{
			WriteData(Data);
		}
	}
}
 
/******************************************************************************/
/*  OLED API                                                                  */
/******************************************************************************/
 
void oled_init(void)							// VCC Generated by Internal DC/DC Circuit
{
	LPC_SYSCON->SYSAHBCLKCTRL |= 1<<16;//只要是复用引脚就得打开IOCON时钟
	
	spi_init(0, 100000, 0);
	
	LPC_GPIO2->DIR |= 1 << 5;
 
	SetDisplayOnOff(0x00);					// Display Off (0x00/0x01)
	SetDisplayClock(0x80);					// Set Clock as 100 Frames/Sec
	SetMultiplexRatio(0x3F);				// 1/64 Duty (0x0F~0x3F)
	SetDisplayOffset(0x00);					// Shift Mapping RAM Counter (0x00~0x3F)
	SetStartLine(0x00);							// Set Mapping RAM Display Start Line (0x00~0x3F)
	SetChargePump(0x04);						// Enable Embedded DC/DC Converter (0x00/0x04)
	SetAddressingMode(0x02);				// Set Page Addressing Mode (0x00/0x01/0x02)
	SetSegmentRemap(0x01);					// Set SEG/Column Mapping (0x00/0x01)
	SetCommonRemap(0x08);						// Set COM/Row Scan Direction (0x00/0x08)
	SetCommonConfig(0x10);					// Set Sequential Configuration (0x00/0x10)
	SetContrastControl(Brightness);	// Set SEG Output Current
	SetPrechargePeriod(0xF1);				// Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
	SetVCOMH(0x40);									// Set VCOM Deselect Level
	SetEntireDisplay(0x00);					// Disable Entire Display On (0x00/0x01)
	SetInverseDisplay(0x00);				// Disable Inverse Display On (0x00/0x01)
 
	FillRAM(0x00);									// Clear Screen
 
	SetDisplayOnOff(0x01);					// Display On (0x00/0x01)
}
 
void oled_clear_screen(void)
{
  FillRAM(0x00);
}
 
/*******************************************************************************
* Function Name  : oled_disp_char
* Description    : Displays a char on the OLED.
* Input          : - Line: the Line where to display the character shape .
*                    This parameter can be one of the following values:
*                       - Linex: where x can be 0..7
*                  - Column: start column address.
*                  - Color: display color
*                       - 0: dot is yellow or blue
*                       - 1: dot is black
*                  - c: character ascii code, must be between 0x20 and 0x7E.
* Output         : None
* Return         : None
*******************************************************************************/
void oled_disp_char(uint8_t Line, uint16_t Column, uint8_t Color, char c)
{
	uint8_t	*Src_Pointer;
	uint8_t	i;
 
	Src_Pointer = (unsigned char *)&ASCII[c - 32][0];
 
	SetStartPage(Line);
	if(Column == 0) {
		SetStartColumn(0);
		if(Color == 0)
			WriteData(0x00);
		else
			WriteData(0xff);
	}
	SetStartColumn(Column+1);
 
  for(i = 0; i < 5; i++) {
		if(Color == 0)
			WriteData(*Src_Pointer);
		else
			WriteData(~(*Src_Pointer));
		Src_Pointer ++;
	}
 
	if(Color == 0)
		WriteData(0x00);
	else
		WriteData(0xff);
}
 
/*******************************************************************************
* Function Name  : oled_disp_string
* Description    : Displays a maximum of 21 char on the OLED.
* Input          : - Line: the Line where to display the character shape .
*                    This parameter can be one of the following values:
*                       - Linex: where x can be 0..9
*                  - Color: display color
*                       - 0: dot is yellow or blue
*                       - 1: dot is black
*                  - *ptr: pointer to string to display on LCD.
* Output         : None
* Return         : None
*******************************************************************************/
void oled_disp_string(uint8_t Line, uint8_t Color, char *ptr)
{
	uint16_t refcolumn = 0;
 
  if(Line < 8) {
		while ((*ptr != 0) & (((refcolumn + 1) & 0xFFFF) < 128)) {
			oled_disp_char(Line, refcolumn, Color, *ptr);
			refcolumn += 6;
			ptr++;
		}
	}
}
 
~~~

## 串口驱动

uart.h

~~~c
#ifndef __UART__
#define __UART__
 
 
void uart_init(void);  
int uart_send(char c);
char uart_recv(void);
 
 
#endif
~~~

uart.c

~~~c
#include <LPC11xx.h>
#include <stdio.h>
#include "uart.h"
 
 
void uart_init(void)
{
	LPC_SYSCON->SYSAHBCLKCTRL |= 1<<16;
 
 
	LPC_IOCON->PIO1_6 &= ~0x07;    /*  UART I/O config */
	LPC_IOCON->PIO1_6 |= 0x01;     /* UART RXD */
	LPC_IOCON->PIO1_7 &= ~0x07;	
	LPC_IOCON->PIO1_7 |= 0x01;     /* UART TXD */
 
	/* Enable UART clock */
	LPC_SYSCON->SYSAHBCLKCTRL |= (1<<12);
	LPC_SYSCON->UARTCLKDIV = 0x1;     
 
	LPC_UART->LCR = 0x83;             /* 8 bits, no Parity, 1 Stop bit */
	
	LPC_UART->DLM = 0;
	LPC_UART->DLL = 16;
	LPC_UART->FDR = 0x85;
	//
	LPC_UART->LCR = 0x03;		/* DLAB = 0 */
	LPC_UART->TER = 1<<7;
 
}
 
int uart_send(char c)
{
	LPC_UART->THR = c;
	while (!(LPC_UART->LSR & (1 << 5))){
		;
	}
	return c;
}
 
char uart_recv(void)
{
	while (!(LPC_UART->LSR & (1 << 0))){
		;
	}
	
	return LPC_UART->RBR;
}
 
int fputc(int ch, FILE *f) 
{	
	return uart_send(ch);
}
 
int fgetc(FILE *f) 
{
  return uart_recv();
}
~~~

## RFID模块驱动

rfid.h


~~~c
#ifndef __RFID_H__
#define __RFID_H__
 
extern unsigned char buf[32];
void rfid_init(void);
int rfid_state(void);
void rfid_read(void);
int rfid_write(unsigned char *wbuf);
 
#endif
 
 
 
 
~~~

rfid.c


~~~c
#include "spi.h"
#include <string.h>
#include <LPC11xx.h>
#include "uart.h"
#include "stdio.h"
 
 
unsigned char buf[32];
 
void delay(unsigned int loop);
 
const unsigned char RFID_READ_DATA_BLOCK_21[10]  = {0x0a, 0x21, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
const unsigned char RFID_WRITE_DATA_BLOCK_22[10] = {0x1a, 0x22, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}; 
 
 
static void delay(unsigned int loop)
{
	int i;
	
	while (loop--) {
		for (i = 10000; i > 0; i--);
	}
}
 
 
/**************************
	rfid初始化
**************************/
 
void rfid_init(void)
{
	
	LPC_SYSCON->SYSAHBCLKCTRL |= 1 << 16;
	SystemCoreClockUpdate();
	SysTick_Config(SystemCoreClock / 500);
	
 
	spi_init(0, 100000, 0);
	
	LPC_GPIO2->DIR &= ~(1 << 8);
}
 
 
/************************
	rfid检测卡片函数
************************/
 
int rfid_state(void)
{
	static unsigned int pre = 1, cur = 1;
	
	cur = (LPC_GPIO2->DATA >> 8) & 1;
	if (cur != pre && pre == 1) {
		pre = cur;
		return 1;
	} else {
		pre = cur;
		return 0;
	}
}
 
unsigned char rfid_checksum(const unsigned char *buf)
{
	int i;
	unsigned char chksum = 0;
	
	for (i = 0; i < buf[0]; i++)
		chksum += buf[i];
	
	return chksum;
}
 
 
/**********************
	rfid读取函数（修改简易版）
	原来的函数用不了，就和
	STM32cubeIDE一个德行
**********************/
 
void rfid_read()
{
	int i;
	unsigned char chksum = rfid_checksum(RFID_READ_DATA_BLOCK_21);
 
	spi_send(0, RFID, 0xAA);
	delay(10);
	spi_send(0, RFID, 0xBB);
	delay(10);
	for (i = 0; i < RFID_READ_DATA_BLOCK_21[0]; i++) {
		spi_send(0, RFID, RFID_READ_DATA_BLOCK_21[i]);
		delay(10);
	}
	spi_send(0, RFID, chksum);
	
	delay(500);
	
	spi_send(0, RFID, 0xAA);
	delay(10);
	spi_send(0, RFID, 0xBB);
	delay(10);
	
	for (i = 0; i < 19; i++) {
		buf[i] = spi_send(0, RFID, 0);
		delay(10);
	}
	
	
//	chksum = rfid_checksum(buf);
//	if (chksum != buf[buf[0]])
//		return -1;
//	else {
//		memcpy(rbuf, buf + 2, 16);
//		return 0;
//	}
	
	
	
 
/****************************
	注释代码经过使用串口设置断点得知，会使得程序进入死循环，具体原因不明
	并且，全部代码在使用指针返回读取到的ID卡号时，串口没法打印，OLED没法显
	示，所以采用全局变量，并在头文件中用extern修饰。调用方式如下：
	
	int rfid_read(unsigned char *rbuf)
	{
	
		.......................
	
	}
	
	
	int main（）
	{
		unsigned char *rbuf;
		int state；
		rfid_init();
		uartinit();
		while(1)
		{
			if(rfid_state())
			{
				printf("找到卡片")；
				state=rfid_read(buf);
				if(staate==0)
				printf("%s",buf);
				else if(state===-1)
				printf("读取失败")；
			}
		}
	}
在显示找到卡片后，代码就处于一个停止状态。
上述代码的正常运行情况应该是，在显示找到卡片之后
如果读取成功就通过串口打印ID，失败就打印，读取失败
，并且是循环打印，但是，这东西是直接死机了。硬件问题
硬件问题
****************************/
}
 
 
 
 
 
 
 
/********************************
	写函数
（
	向ID卡写入数据，通过这个函数；
	可以将ID卡读取的信息进行改变;
	比如，我们可以将我们所使用的;
	money：100修改为，I am cool man;
	unsigned char *str="I am cool man"
	rfid_write(str);
）
********************************/
int rfid_write(unsigned char *wbuf)
{
	int i;
	unsigned char chksum;
	unsigned char buf[32];
 
	memcpy(buf, RFID_WRITE_DATA_BLOCK_22, 10);
	memcpy(buf + 10, wbuf, 16);
	chksum = rfid_checksum(buf);
 
	spi_send(0, RFID, 0xAA);
	delay(10);
	spi_send(0, RFID, 0xBB);
	delay(10);
	for (i = 0; i < buf[0]; i++) {
		spi_send(0, RFID, buf[i]);
		delay(10);
	}
	spi_send(0, RFID, chksum);
	
	delay(500);
	
	spi_send(0, RFID, 0xAA);
	delay(10);
	spi_send(0, RFID, 0xBB);
	delay(10);
	
	for (i = 0; i < 3; i++) {
		buf[i] = spi_send(0, RFID, 0);
		delay(10);
	}
	
	if (buf[0] != 3 || buf[1] != 0x22)
		return -1;
	else
		return 0;
}
 
 
 
 
void SysTick_Handler(void)
{
	
}
 
 
~~~

## 光强传感器驱动

i2c.h

~~~c
#ifndef __I2C_H__
#define __I2C_H__
 
void i2c_init(void);
int i2c_write(unsigned char addr, unsigned char reg, unsigned char *buf, int len);
int i2c_read(unsigned char addr, unsigned char reg, unsigned char *buf, int len);
 
#endif
~~~

i2c.c

~~~c
#include <stdbool.h>
#include <LPC11xx.h>
 
bool i2c_start(void);
bool i2c_stop(void);
 
void i2c_init(void)
{
	LPC_SYSCON->PRESETCTRL |= 1 << 1;
	LPC_SYSCON->SYSAHBCLKCTRL |= 1 << 5;
	
	LPC_IOCON->PIO0_4 = 0x01;
	LPC_IOCON->PIO0_5 = 0x01;
	LPC_I2C->SCLH = 480;
	LPC_I2C->SCLL = 480;
	LPC_I2C->CONCLR |= (1 << 2) | (1 << 3) | (1 << 5) | (1 << 6);
	LPC_I2C->CONSET |= (1 << 6);
}
 
bool i2c_start(void)
{
	LPC_I2C->CONSET = (1 << 5);							/* START */
	while (!(LPC_I2C->CONSET & (1 << 3)));	/* wait interrupt */
	if (LPC_I2C->STAT != 0x08 && LPC_I2C->STAT != 0x10) {
		i2c_stop();
		return false;
	}
	return true;
}
 
bool i2c_stop(void)
{
	LPC_I2C->CONSET = (1 << 4);							/* Set Stop flag */ 
  LPC_I2C->CONCLR = (1 << 3);							/* Clear SI flag */ 
  while(LPC_I2C->CONSET & (1 << 4));			/* Wait for STOP detected */
	return true;
}
 
bool i2c_send_sla(unsigned char addr)
{
	LPC_I2C->DAT = addr;
	LPC_I2C->CONCLR = (1 << 5) | (1 << 3);	/* clear interrupt and sta */
	while (!(LPC_I2C->CONSET & (1 << 3)));	/* wait interrupt */
	if (LPC_I2C->STAT != 0x18 && LPC_I2C->STAT != 0x40) {
		i2c_stop();
		return false;
	} else
		return true;
}
 
bool i2c_send_dat(unsigned char dat)
{
	LPC_I2C->DAT = dat;
	LPC_I2C->CONCLR = (1 << 5) | (1 << 3);	/* clear interrupt and sta */
	while (!(LPC_I2C->CONSET & (1 << 3)));	/* wait interrupt */
	if (LPC_I2C->STAT != 0x28) {
		i2c_stop();
		return false;
	} else
		return true;
}
 
bool i2c_recv_dat(unsigned char *dat, bool ack)
{
	if (!ack)
		LPC_I2C->CONCLR = 1 << 2;
	else
		LPC_I2C->CONSET = 1 << 2;
	LPC_I2C->CONCLR = 1 << 3;
	while (!(LPC_I2C->CONSET & (1 << 3)));	/* wait interrupt */
	if (LPC_I2C->STAT != 0x50 && LPC_I2C->STAT != 0x58) {
		i2c_stop();
		return false;
	}
	*dat = LPC_I2C->DAT;
	return true;
}
 
int i2c_write(unsigned char addr, unsigned char reg, unsigned char *buf, int len)
{
	int i;
	
	/* 1. transmit a START condition */
	if (!i2c_start())
		return -1;
 
	/* 2. send slave address */
	if (!i2c_send_sla(addr << 1))
		return -1;
 
	/* 3. send register address */
	if (!i2c_send_dat(reg))
		return -1;
	
	/* 4. send data */
	for (i = 0; i < len; i++) {
		if (!i2c_send_dat(buf[i]))
			return i;
	}
 
	/* 5. generate stop */
	i2c_stop();
	
	return len;
}
 
int i2c_read(unsigned char addr, unsigned char reg, unsigned char *buf, int len)
{
	int i = len;
	
	/* 1. transmit a START condition */
	if (!i2c_start())
		return -1;
 
	/* 2. send slave address */
	if (!i2c_send_sla(addr << 1))
		return -1;
 
	/* 3. send register address */
	if (!i2c_send_dat(reg))
		return -1;
	
	/* 4. nonstandard */
	i2c_stop();
	
	/* 5. transmit a START condition */
	if (!i2c_start())
		return -1;
 
	/* 5. send slave address */
	if (!i2c_send_sla((addr << 1) | 1))
		return -1;
	
	/* 6. receive data */
	while (i) {
		if (i == 1) {
			if (!i2c_recv_dat(buf + len - i, false))
				return len - i;
		} else {
			if (!i2c_recv_dat(buf + len - i, true))
				return len - i;
		}
		i--;
	}
	
	/* 7. transmit a STOP condition */
	i2c_stop();
	
	return len;
}
~~~

light.h

~~~c
#ifndef __LIGHT_H__
#define __LIGHT_H__
 
void light_init(void);
unsigned short light_get(void);
void light_set_thr(unsigned short thrhi, unsigned short thrlo);
 
#endif
~~~

light.c

~~~c
#include "i2c.h"
 
#define ISL29003_ADDR	0x44
#define COMMAND				0
#define CONTROL				1
#define THRHI					2
#define THRLO					3
#define LUXLSB				4
#define LUXMSB				5
#define TMRLSB				6
#define TMRMSB				7
 
void light_init(void)
{
	
	/*
	 * 2^16 cycles, Diode1's current to unsigned 16-bit data, 
	 * Integration is internally timed, Normal operation, enable ADC-core
	 */
	unsigned char cmd = (1 << 7);
	/*
	 * 0 to 64000 lux, 
	 * Interrupt is triggered after 8 integration cycles
	 */
	unsigned char ctl = (3 << 2) | (2 << 0);
	
	i2c_init();
	
	
	i2c_write(ISL29003_ADDR, COMMAND, &cmd, 1);
	i2c_write(ISL29003_ADDR, CONTROL, &ctl, 1);
}
 
unsigned short light_get(void)
{
	unsigned short lux;
	
	i2c_read(ISL29003_ADDR, LUXLSB, (unsigned char *)&lux, 2);
 
	return lux;
}
 
void light_set_thr(unsigned short thrhi, unsigned short thrlo)
{
	unsigned char buf[2];
 
	buf[0] = thrhi >> 8;
	buf[1] = thrlo >> 8;
	i2c_write(ISL29003_ADDR, COMMAND, buf, 1);
}
~~~

用这个开发板的应该是在参加华清远见的实训或者学校采购了华清远见的开发板。各位好运。

[原文链接](https://blog.csdn.net/m0_54052950/article/details/130534961)